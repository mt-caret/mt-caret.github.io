var data = {lines:[
{"lineNum":"    1","line":"use crate::utils::PolarsDataType;"},
{"lineNum":"    2","line":"use crate::utils::*;"},
{"lineNum":"    3","line":"use chrono::naive::{NaiveDate, NaiveDateTime};"},
{"lineNum":"    4","line":"use ocaml_interop::{DynBox, OCaml, OCamlInt, OCamlList, OCamlRef, ToOCaml};"},
{"lineNum":"    5","line":"use polars::prelude::*;"},
{"lineNum":"    6","line":"use polars_ocaml_macros::ocaml_interop_export;"},
{"lineNum":"    7","line":""},
{"lineNum":"    8","line":"#[ocaml_interop_export(raise_on_err)]","class":"lineCov","hits":"1","order":"442",},
{"lineNum":"    9","line":"fn rust_naive_date("},
{"lineNum":"   10","line":"    cr: &mut &mut OCamlRuntime,"},
{"lineNum":"   11","line":"    year: OCamlRef<OCamlInt>,","class":"lineCov","hits":"1","order":"443",},
{"lineNum":"   12","line":"    month: OCamlRef<OCamlInt>,","class":"lineCov","hits":"1","order":"444",},
{"lineNum":"   13","line":"    day: OCamlRef<OCamlInt>,","class":"lineCov","hits":"1","order":"445",},
{"lineNum":"   14","line":") -> OCaml<Option<DynBox<NaiveDate>>> {"},
{"lineNum":"   15","line":"    let year: i32 = year.to_rust(cr);","class":"lineCov","hits":"1","order":"446",},
{"lineNum":"   16","line":"    let month = month.to_rust::<Coerce<_, i32, u32>>(cr).get()?;","class":"lineCov","hits":"1","order":"447",},
{"lineNum":"   17","line":"    let day = day.to_rust::<Coerce<_, i32, u32>>(cr).get()?;","class":"lineCov","hits":"1","order":"452",},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"    NaiveDate::from_ymd_opt(year, month, day)","class":"lineCov","hits":"1","order":"453",},
{"lineNum":"   20","line":"        .map(Abstract)"},
{"lineNum":"   21","line":"        .to_ocaml(cr)","class":"lineCov","hits":"1","order":"454",},
{"lineNum":"   22","line":"}"},
{"lineNum":"   23","line":""},
{"lineNum":"   24","line":"#[ocaml_interop_export(raise_on_err)]","class":"lineCov","hits":"1","order":"466",},
{"lineNum":"   25","line":"fn rust_naive_date_to_naive_datetime("},
{"lineNum":"   26","line":"    cr: &mut &mut OCamlRuntime,"},
{"lineNum":"   27","line":"    date: OCamlRef<DynBox<NaiveDate>>,","class":"lineCov","hits":"1","order":"467",},
{"lineNum":"   28","line":"    hour: OCamlRef<Option<OCamlInt>>,","class":"lineCov","hits":"1","order":"468",},
{"lineNum":"   29","line":"    min: OCamlRef<Option<OCamlInt>>,","class":"lineCov","hits":"1","order":"469",},
{"lineNum":"   30","line":"    sec: OCamlRef<Option<OCamlInt>>,","class":"lineCov","hits":"1","order":"470",},
{"lineNum":"   31","line":") -> OCaml<Option<DynBox<NaiveDateTime>>> {"},
{"lineNum":"   32","line":"    let Abstract(date) = date.to_rust(cr);","class":"lineCov","hits":"1","order":"471",},
{"lineNum":"   33","line":""},
{"lineNum":"   34","line":"    let hour: u32 = hour","class":"lineCov","hits":"1","order":"473",},
{"lineNum":"   35","line":"        .to_rust::<Coerce<_, Option<i64>, Option<u32>>>(cr)","class":"lineCov","hits":"1","order":"472",},
{"lineNum":"   36","line":"        .get()?","class":"lineNoCov","hits":"0",},
{"lineNum":"   37","line":"        .unwrap_or(0);"},
{"lineNum":"   38","line":"    let min: u32 = min","class":"lineCov","hits":"1","order":"476",},
{"lineNum":"   39","line":"        .to_rust::<Coerce<_, Option<i64>, Option<u32>>>(cr)","class":"lineCov","hits":"1","order":"475",},
{"lineNum":"   40","line":"        .get()?","class":"lineNoCov","hits":"0",},
{"lineNum":"   41","line":"        .unwrap_or(0);"},
{"lineNum":"   42","line":"    let sec: u32 = sec","class":"lineCov","hits":"1","order":"478",},
{"lineNum":"   43","line":"        .to_rust::<Coerce<_, Option<i64>, Option<u32>>>(cr)","class":"lineCov","hits":"1","order":"477",},
{"lineNum":"   44","line":"        .get()?","class":"lineNoCov","hits":"0",},
{"lineNum":"   45","line":"        .unwrap_or(0);"},
{"lineNum":"   46","line":""},
{"lineNum":"   47","line":"    date.and_hms_opt(hour, min, sec).map(Abstract).to_ocaml(cr)","class":"lineCov","hits":"1","order":"479",},
{"lineNum":"   48","line":"}"},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"#[ocaml_interop_export]","class":"lineCov","hits":"1","order":"1555",},
{"lineNum":"   51","line":"fn rust_naive_datetime_to_string("},
{"lineNum":"   52","line":"    cr: &mut &mut OCamlRuntime,"},
{"lineNum":"   53","line":"    datetime: OCamlRef<DynBox<NaiveDateTime>>,","class":"lineCov","hits":"1","order":"1556",},
{"lineNum":"   54","line":") -> OCaml<String> {"},
{"lineNum":"   55","line":"    let Abstract(datetime) = datetime.to_rust(cr);","class":"lineCov","hits":"1","order":"1557",},
{"lineNum":"   56","line":""},
{"lineNum":"   57","line":"    datetime.to_string().to_ocaml(cr)","class":"lineCov","hits":"1","order":"1558",},
{"lineNum":"   58","line":"}"},
{"lineNum":"   59","line":""},
{"lineNum":"   60","line":"#[ocaml_interop_export]","class":"lineCov","hits":"1","order":"45",},
{"lineNum":"   61","line":"fn rust_time_ns_to_naive_datetime("},
{"lineNum":"   62","line":"    cr: &mut &mut OCamlRuntime,"},
{"lineNum":"   63","line":"    time_ns: OCamlRef<OCamlInt63>,","class":"lineCov","hits":"1","order":"46",},
{"lineNum":"   64","line":") -> OCaml<Option<DynBox<NaiveDateTime>>> {"},
{"lineNum":"   65","line":"    let OCamlInt63(ns_since_epoch) = time_ns.to_rust(cr);","class":"lineCov","hits":"1","order":"47",},
{"lineNum":"   66","line":""},
{"lineNum":"   67","line":"    // We use Euclidean division here instead of the usual div (/) and mod (%)"},
{"lineNum":"   68","line":"    // operations since we need the remainder to be non-negative."},
{"lineNum":"   69","line":"    NaiveDateTime::from_timestamp_opt(","class":"lineCov","hits":"1","order":"54",},
{"lineNum":"   70","line":"        ns_since_epoch.div_euclid(1_000_000_000),","class":"lineCov","hits":"1","order":"52",},
{"lineNum":"   71","line":"        ns_since_epoch.rem_euclid(1_000_000_000) as u32,","class":"lineCov","hits":"1","order":"53",},
{"lineNum":"   72","line":"    )"},
{"lineNum":"   73","line":"    .map(Abstract)"},
{"lineNum":"   74","line":"    .to_ocaml(cr)","class":"lineCov","hits":"1","order":"56",},
{"lineNum":"   75","line":"}"},
{"lineNum":"   76","line":""},
{"lineNum":"   77","line":"#[ocaml_interop_export]","class":"lineCov","hits":"1","order":"60",},
{"lineNum":"   78","line":"fn rust_naive_datetime_to_timestamp_nanos("},
{"lineNum":"   79","line":"    cr: &mut &mut OCamlRuntime,"},
{"lineNum":"   80","line":"    datetime: OCamlRef<DynBox<NaiveDateTime>>,","class":"lineCov","hits":"1","order":"61",},
{"lineNum":"   81","line":") -> OCaml<OCamlInt> {"},
{"lineNum":"   82","line":"    let Abstract(datetime) = datetime.to_rust(cr);","class":"lineCov","hits":"1","order":"62",},
{"lineNum":"   83","line":""},
{"lineNum":"   84","line":"    datetime.timestamp_nanos().to_ocaml(cr)","class":"lineCov","hits":"1","order":"66",},
{"lineNum":"   85","line":"}"},
{"lineNum":"   86","line":""},
{"lineNum":"   87","line":"#[ocaml_interop_export]","class":"lineCov","hits":"1","order":"67",},
{"lineNum":"   88","line":"fn rust_schema_create("},
{"lineNum":"   89","line":"    cr: &mut &mut OCamlRuntime,"},
{"lineNum":"   90","line":"    fields: OCamlRef<OCamlList<(String, DataType)>>,","class":"lineCov","hits":"1","order":"68",},
{"lineNum":"   91","line":") -> OCaml<DynBox<Schema>> {"},
{"lineNum":"   92","line":"    let fields: Vec<(String, PolarsDataType)> = fields.to_rust(cr);","class":"lineCov","hits":"1","order":"69",},
{"lineNum":"   93","line":"    let schema: Schema = fields","class":"lineCov","hits":"1","order":"88",},
{"lineNum":"   94","line":"        .into_iter()"},
{"lineNum":"   95","line":"        .map(|(name, PolarsDataType(data_type))| Field::new(&name, data_type))","class":"lineCov","hits":"1","order":"89",},
{"lineNum":"   96","line":"        .collect();"},
{"lineNum":"   97","line":"    OCaml::box_value(cr, schema)","class":"lineCov","hits":"1","order":"90",},
{"lineNum":"   98","line":"}"},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":"#[ocaml_interop_export]","class":"lineCov","hits":"1","order":"91",},
{"lineNum":"  101","line":"fn rust_schema_to_fields("},
{"lineNum":"  102","line":"    cr: &mut &mut OCamlRuntime,"},
{"lineNum":"  103","line":"    schema: OCamlRef<DynBox<Schema>>,","class":"lineCov","hits":"1","order":"92",},
{"lineNum":"  104","line":") -> OCaml<OCamlList<(String, DataType)>> {"},
{"lineNum":"  105","line":"    let Abstract(schema) = schema.to_rust(cr);","class":"lineCov","hits":"1","order":"93",},
{"lineNum":"  106","line":"    let fields: Vec<(String, PolarsDataType)> = schema","class":"lineCov","hits":"1","order":"94",},
{"lineNum":"  107","line":"        .iter_fields()"},
{"lineNum":"  108","line":"        .map(|Field { name, dtype }| (name.to_string(), PolarsDataType(dtype)))","class":"lineCov","hits":"1","order":"95",},
{"lineNum":"  109","line":"        .collect();"},
{"lineNum":"  110","line":"    fields.to_ocaml(cr)","class":"lineCov","hits":"1","order":"96",},
{"lineNum":"  111","line":"}","class":"lineCov","hits":"1","order":"139",},
{"lineNum":"  112","line":""},
{"lineNum":"  113","line":"#[ocaml_interop_export]","class":"lineCov","hits":"1","order":"279",},
{"lineNum":"  114","line":"fn rust_test_panic(cr: &mut &mut OCamlRuntime, error_message: OCamlRef<String>) -> OCaml<()> {","class":"lineCov","hits":"1","order":"280",},
{"lineNum":"  115","line":"    let error_message: String = error_message.to_rust(cr);","class":"lineCov","hits":"1","order":"281",},
{"lineNum":"  116","line":""},
{"lineNum":"  117","line":"    // We use a meaningless if branch here to get rid of the unreachable"},
{"lineNum":"  118","line":"    // expression warning."},
{"lineNum":"  119","line":"    if true {","class":"lineCov","hits":"1","order":"282",},
{"lineNum":"  120","line":"        panic!(\"test panic: {}\", error_message);","class":"lineCov","hits":"1","order":"283",},
{"lineNum":"  121","line":"    }"},
{"lineNum":"  122","line":""},
{"lineNum":"  123","line":"    OCaml::unit()","class":"lineNoCov","hits":"0",},
{"lineNum":"  124","line":"}","class":"lineCov","hits":"1","order":"284",},
{"lineNum":"  125","line":""},
{"lineNum":"  126","line":"#[ocaml_interop_export]","class":"lineCov","hits":"1","order":"1",},
{"lineNum":"  127","line":"fn rust_test_fill_null_strategy("},
{"lineNum":"  128","line":"    cr: &mut &mut OCamlRuntime,"},
{"lineNum":"  129","line":"    fill_null_strategy: OCamlRef<FillNullStrategy>,","class":"lineCov","hits":"1","order":"2",},
{"lineNum":"  130","line":") -> OCaml<FillNullStrategy> {"},
{"lineNum":"  131","line":"    let PolarsFillNullStrategy(fill_null_strategy) = fill_null_strategy.to_rust(cr);","class":"lineCov","hits":"1","order":"4",},
{"lineNum":"  132","line":""},
{"lineNum":"  133","line":"    PolarsFillNullStrategy(fill_null_strategy).to_ocaml(cr)","class":"lineCov","hits":"1","order":"9",},
{"lineNum":"  134","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "inline_test_runner_polars_tests.exe", "date" : "2023-09-17 15:58:55", "instrumented" : 64, "covered" : 60,};
var merged_data = [];
