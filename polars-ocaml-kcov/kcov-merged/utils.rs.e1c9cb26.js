var data = {lines:[
{"lineNum":"    1","line":"use ocaml_interop::{"},
{"lineNum":"    2","line":"    impl_from_ocaml_variant, ocaml_alloc_polymorphic_variant, ocaml_alloc_tagged_block,"},
{"lineNum":"    3","line":"    ocaml_alloc_variant, ocaml_unpack_polymorphic_variant, ocaml_unpack_variant,"},
{"lineNum":"    4","line":"    polymorphic_variant_tag_hash, BoxRoot, DynBox, FromOCaml, OCaml, OCamlInt, OCamlList,"},
{"lineNum":"    5","line":"    OCamlRuntime, ToOCaml,"},
{"lineNum":"    6","line":"};"},
{"lineNum":"    7","line":"use polars::series::IsSorted;"},
{"lineNum":"    8","line":"use polars::{lazy::dsl::WindowMapping, prelude::*};"},
{"lineNum":"    9","line":"use smartstring::{LazyCompact, SmartString};"},
{"lineNum":"   10","line":"use std::any::type_name;"},
{"lineNum":"   11","line":"use std::borrow::Borrow;"},
{"lineNum":"   12","line":"use std::fmt::Debug;"},
{"lineNum":"   13","line":"use std::marker::PhantomData;"},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"macro_rules! dyn_box {"},
{"lineNum":"   16","line":"    ($cr:ident, |$($var:ident),+| $body:expr) => {"},
{"lineNum":"   17","line":"        {"},
{"lineNum":"   18","line":"            $("},
{"lineNum":"   19","line":"                let Abstract($var) = $var.to_rust($cr);"},
{"lineNum":"   20","line":"            )+"},
{"lineNum":"   21","line":""},
{"lineNum":"   22","line":"            OCaml::box_value($cr, $body)"},
{"lineNum":"   23","line":"        }"},
{"lineNum":"   24","line":"    };"},
{"lineNum":"   25","line":"}"},
{"lineNum":"   26","line":""},
{"lineNum":"   27","line":"macro_rules! dyn_box_result {"},
{"lineNum":"   28","line":"    ($cr:ident, |$($var:ident),+| $body:expr) => {"},
{"lineNum":"   29","line":"        {"},
{"lineNum":"   30","line":"            $("},
{"lineNum":"   31","line":"                let Abstract($var) = $var.to_rust($cr);"},
{"lineNum":"   32","line":"            )+"},
{"lineNum":"   33","line":""},
{"lineNum":"   34","line":"            $body.map(Abstract).map_err(|err| err.to_string()).to_ocaml($cr)","class":"lineCov","hits":"1","order":"937",},
{"lineNum":"   35","line":"        }"},
{"lineNum":"   36","line":"    };"},
{"lineNum":"   37","line":"}"},
{"lineNum":"   38","line":""},
{"lineNum":"   39","line":"macro_rules! dyn_box_op {"},
{"lineNum":"   40","line":"    ($name:ident, $type:ty, |$($var:ident),+| $body:expr) => {"},
{"lineNum":"   41","line":"        #[ocaml_interop_export]","class":"lineCov","hits":"1","order":"925",},
{"lineNum":"   42","line":"        fn $name("},
{"lineNum":"   43","line":"            cr: &mut &mut OCamlRuntime,"},
{"lineNum":"   44","line":"            $("},
{"lineNum":"   45","line":"                $var: OCamlRef<DynBox<$type>>,"},
{"lineNum":"   46","line":"            )+"},
{"lineNum":"   47","line":"        ) -> OCaml<DynBox<$type>> {"},
{"lineNum":"   48","line":"            dyn_box!(cr, |$($var),+| $body)"},
{"lineNum":"   49","line":"        }"},
{"lineNum":"   50","line":"    }"},
{"lineNum":"   51","line":"}"},
{"lineNum":"   52","line":""},
{"lineNum":"   53","line":"macro_rules! dyn_box_op_result {"},
{"lineNum":"   54","line":"    ($name:ident, $type:ty, |$($var:ident),+| $body:expr) => {"},
{"lineNum":"   55","line":"        #[ocaml_interop_export]","class":"lineNoCov","hits":"0",},
{"lineNum":"   56","line":"        fn $name("},
{"lineNum":"   57","line":"            cr: &mut &mut OCamlRuntime,"},
{"lineNum":"   58","line":"            $("},
{"lineNum":"   59","line":"                $var: OCamlRef<DynBox<$type>>,"},
{"lineNum":"   60","line":"            )+"},
{"lineNum":"   61","line":"        ) -> OCaml<Result<DynBox<$type>, String>> {"},
{"lineNum":"   62","line":"            dyn_box_result!(cr, |$($var),+| $body)"},
{"lineNum":"   63","line":"        }","class":"lineNoCov","hits":"0",},
{"lineNum":"   64","line":"    }"},
{"lineNum":"   65","line":"}"},
{"lineNum":"   66","line":""},
{"lineNum":"   67","line":"pub(crate) use dyn_box;"},
{"lineNum":"   68","line":"pub(crate) use dyn_box_op;"},
{"lineNum":"   69","line":"pub(crate) use dyn_box_op_result;"},
{"lineNum":"   70","line":"pub(crate) use dyn_box_result;"},
{"lineNum":"   71","line":""},
{"lineNum":"   72","line":"// This function is actually quite unsafe; as a general rule, additional use of"},
{"lineNum":"   73","line":"// this is strongly discouraged. See comment for `raise_ocaml_exception` in the"},
{"lineNum":"   74","line":"// implementation of `ocaml_interop_backtrace_support` for more details."},
{"lineNum":"   75","line":"//"},
{"lineNum":"   76","line":"// TODO: we unfortunately can\'t use `ocaml_sys::caml_failwith_value` which would"},
{"lineNum":"   77","line":"// prevent us from leaking memory since `cr` isn\'t accessible in `from_ocaml`"},
{"lineNum":"   78","line":"// calls which are where this function is being used (and I\'m not sure"},
{"lineNum":"   79","line":"// recovering the runtime in these place is safe)."},
{"lineNum":"   80","line":"pub unsafe fn ocaml_failwith(error_message: &str) -> ! {","class":"lineCov","hits":"1","order":"1665",},
{"lineNum":"   81","line":"    let error_message = std::ffi::CString::new(error_message).expect(\"CString::new failed\");","class":"lineCov","hits":"1","order":"1640",},
{"lineNum":"   82","line":"    unsafe {"},
{"lineNum":"   83","line":"        ocaml_sys::caml_failwith(error_message.as_ptr());","class":"lineCov","hits":"1","order":"1647",},
{"lineNum":"   84","line":"    }"},
{"lineNum":"   85","line":"    unreachable!(\"caml_failwith should never return\")","class":"lineNoCov","hits":"0",},
{"lineNum":"   86","line":"}","class":"lineNoCov","hits":"0",},
{"lineNum":"   87","line":""},
{"lineNum":"   88","line":"polars_ocaml_macros::ocaml_interop_backtrace_support!();","class":"lineCov","hits":"1","order":"1651",},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"// TODO: add this to ocaml-interop?"},
{"lineNum":"   91","line":"pub struct OCamlUniformArray<A> {"},
{"lineNum":"   92","line":"    _marker: PhantomData<A>,"},
{"lineNum":"   93","line":"}"},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"unsafe impl<A, OCamlA> FromOCaml<OCamlUniformArray<OCamlA>> for Vec<A>"},
{"lineNum":"   96","line":"where"},
{"lineNum":"   97","line":"    A: FromOCaml<OCamlA>,"},
{"lineNum":"   98","line":"{"},
{"lineNum":"   99","line":"    fn from_ocaml(v: OCaml<OCamlUniformArray<OCamlA>>) -> Self {","class":"lineCov","hits":"1","order":"1616",},
{"lineNum":"  100","line":"        let size = unsafe { ocaml_sys::wosize_val(v.raw()) };","class":"lineCov","hits":"1","order":"1607",},
{"lineNum":"  101","line":""},
{"lineNum":"  102","line":"        // tuple/record/array tag, note that we do not expect a double array"},
{"lineNum":"  103","line":"        // tag, since uniform array guarantee boxing."},
{"lineNum":"  104","line":"        assert_eq!(v.tag_value(), 0);","class":"lineCov","hits":"1","order":"1605",},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"        let mut vec = Vec::with_capacity(size);","class":"lineCov","hits":"1","order":"1720",},
{"lineNum":"  107","line":"        for i in 0..size {","class":"lineCov","hits":"1","order":"1662",},
{"lineNum":"  108","line":"            vec.push(OCaml::<_>::to_rust(&unsafe { v.field(i) }));","class":"lineCov","hits":"1","order":"1674",},
{"lineNum":"  109","line":"        }"},
{"lineNum":"  110","line":"        vec","class":"lineCov","hits":"1","order":"1638",},
{"lineNum":"  111","line":"    }","class":"lineCov","hits":"1","order":"1648",},
{"lineNum":"  112","line":"}"},
{"lineNum":"  113","line":""},
{"lineNum":"  114","line":"pub struct OCamlInt63(pub i64);"},
{"lineNum":"  115","line":""},
{"lineNum":"  116","line":"unsafe impl FromOCaml<OCamlInt63> for OCamlInt63 {"},
{"lineNum":"  117","line":"    fn from_ocaml(v: OCaml<OCamlInt63>) -> Self {","class":"lineCov","hits":"1","order":"1254",},
{"lineNum":"  118","line":"        if v.is_block() {","class":"lineCov","hits":"1","order":"1253",},
{"lineNum":"  119","line":"            let int64 = {"},
{"lineNum":"  120","line":"                let val = unsafe { ocaml_sys::field(v.raw(), 1) };","class":"lineNoCov","hits":"0",},
{"lineNum":"  121","line":"                unsafe { *(val as *const i64) }","class":"lineNoCov","hits":"0",},
{"lineNum":"  122","line":"            };"},
{"lineNum":"  123","line":""},
{"lineNum":"  124","line":"            // Base\'s implementation of `Int63.t` on 32bit platforms is `Int64.t`"},
{"lineNum":"  125","line":"            // (a block holding an i64) shifted left with lower bit 0 to match"},
{"lineNum":"  126","line":"            // the semantics of `int` on 64bit platforms."},
{"lineNum":"  127","line":"            OCamlInt63(int64 >> 1)","class":"lineNoCov","hits":"0",},
{"lineNum":"  128","line":"        } else {"},
{"lineNum":"  129","line":"            // On 64bit platforms, `Int63.t` is just a regular old OCaml integer."},
{"lineNum":"  130","line":"            OCamlInt63(unsafe { ocaml_sys::int_val(v.raw()) as i64 })","class":"lineCov","hits":"1","order":"1255",},
{"lineNum":"  131","line":"        }"},
{"lineNum":"  132","line":"    }","class":"lineCov","hits":"1","order":"1256",},
{"lineNum":"  133","line":"}"},
{"lineNum":"  134","line":""},
{"lineNum":"  135","line":"pub struct PolarsTimeUnit(pub TimeUnit);"},
{"lineNum":"  136","line":""},
{"lineNum":"  137","line":"unsafe impl FromOCaml<TimeUnit> for PolarsTimeUnit {"},
{"lineNum":"  138","line":"    fn from_ocaml(v: OCaml<TimeUnit>) -> Self {","class":"lineCov","hits":"1","order":"947",},
{"lineNum":"  139","line":"        let result = ocaml_unpack_variant! {","class":"lineCov","hits":"1","order":"965",},
{"lineNum":"  140","line":"            v => {"},
{"lineNum":"  141","line":"                TimeUnit::Nanoseconds,"},
{"lineNum":"  142","line":"                TimeUnit::Microseconds,"},
{"lineNum":"  143","line":"                TimeUnit::Milliseconds,"},
{"lineNum":"  144","line":"            }"},
{"lineNum":"  145","line":"        };"},
{"lineNum":"  146","line":"        PolarsTimeUnit(result.expect(\"Failure when unpacking an OCaml<TimeUnit> variant into PolarsTimeUnit (unexpected tag value\"))","class":"lineCov","hits":"1","order":"979",},
{"lineNum":"  147","line":"    }","class":"lineCov","hits":"1","order":"971",},
{"lineNum":"  148","line":"}"},
{"lineNum":"  149","line":""},
{"lineNum":"  150","line":"unsafe impl ToOCaml<TimeUnit> for PolarsTimeUnit {"},
{"lineNum":"  151","line":"    fn to_ocaml<\'a>(&self, cr: &\'a mut OCamlRuntime) -> OCaml<\'a, TimeUnit> {","class":"lineCov","hits":"1","order":"1678",},
{"lineNum":"  152","line":"        let PolarsTimeUnit(timeunit) = self;","class":"lineCov","hits":"1","order":"1679",},
{"lineNum":"  153","line":"        ocaml_alloc_variant! {","class":"lineCov","hits":"1","order":"1681",},
{"lineNum":"  154","line":"            cr, timeunit => {"},
{"lineNum":"  155","line":"                TimeUnit::Nanoseconds,"},
{"lineNum":"  156","line":"                TimeUnit::Microseconds,"},
{"lineNum":"  157","line":"                TimeUnit::Milliseconds,"},
{"lineNum":"  158","line":"            }"},
{"lineNum":"  159","line":"        }"},
{"lineNum":"  160","line":"    }","class":"lineCov","hits":"1","order":"1682",},
{"lineNum":"  161","line":"}"},
{"lineNum":"  162","line":""},
{"lineNum":"  163","line":"pub struct PolarsDataType(pub DataType);"},
{"lineNum":"  164","line":""},
{"lineNum":"  165","line":"unsafe impl FromOCaml<DataType> for PolarsDataType {"},
{"lineNum":"  166","line":"    fn from_ocaml(v: OCaml<DataType>) -> Self {","class":"lineCov","hits":"1","order":"980",},
{"lineNum":"  167","line":"        let result = ocaml_unpack_variant! {","class":"lineCov","hits":"1","order":"981",},
{"lineNum":"  168","line":"            v => {"},
{"lineNum":"  169","line":"                DataType::Boolean,"},
{"lineNum":"  170","line":"                DataType::UInt8,"},
{"lineNum":"  171","line":"                DataType::UInt16,"},
{"lineNum":"  172","line":"                DataType::UInt32,"},
{"lineNum":"  173","line":"                DataType::UInt64,"},
{"lineNum":"  174","line":"                DataType::Int8,"},
{"lineNum":"  175","line":"                DataType::Int16,"},
{"lineNum":"  176","line":"                DataType::Int32,"},
{"lineNum":"  177","line":"                DataType::Int64,"},
{"lineNum":"  178","line":"                DataType::Float32,"},
{"lineNum":"  179","line":"                DataType::Float64,"},
{"lineNum":"  180","line":"                DataType::Utf8,"},
{"lineNum":"  181","line":"                DataType::Binary,"},
{"lineNum":"  182","line":"                DataType::Date,"},
{"lineNum":"  183","line":"                DataType::Datetime(timeunit: TimeUnit, timezone: Option<String>) => {"},
{"lineNum":"  184","line":"                    let PolarsTimeUnit(timeunit) = timeunit;","class":"lineCov","hits":"1","order":"933",},
{"lineNum":"  185","line":"                    DataType::Datetime(timeunit, timezone)},","class":"lineCov","hits":"1","order":"931",},
{"lineNum":"  186","line":"                DataType::Duration(timeunit: TimeUnit) => {"},
{"lineNum":"  187","line":"                    let PolarsTimeUnit(timeunit) = timeunit;","class":"lineCov","hits":"1","order":"1631",},
{"lineNum":"  188","line":"                    DataType::Duration(timeunit)},","class":"lineCov","hits":"1","order":"1657",},
{"lineNum":"  189","line":"                DataType::Time,"},
{"lineNum":"  190","line":"                DataType::List(datatype: DataType) => {"},
{"lineNum":"  191","line":"                    let PolarsDataType(datatype) = datatype;","class":"lineCov","hits":"1","order":"1670",},
{"lineNum":"  192","line":"                    DataType::List(Box::new(datatype))","class":"lineCov","hits":"1","order":"1671",},
{"lineNum":"  193","line":"                },"},
{"lineNum":"  194","line":"                DataType::Null,"},
{"lineNum":"  195","line":"                DataType::Struct(fields: OCamlList<(String, DataType)>) => {"},
{"lineNum":"  196","line":"                    let fields_: Vec<(String, PolarsDataType)> = fields;","class":"lineCov","hits":"1","order":"1625",},
{"lineNum":"  197","line":"                    let fields: Vec<Field> ="},
{"lineNum":"  198","line":"                        fields_","class":"lineCov","hits":"1","order":"1624",},
{"lineNum":"  199","line":"                        .into_iter()"},
{"lineNum":"  200","line":"                        .map(|(name, PolarsDataType(datatype))| Field { name: SmartString::from(name), dtype: datatype })","class":"lineCov","hits":"1","order":"1627",},
{"lineNum":"  201","line":"                        .collect();"},
{"lineNum":"  202","line":"                    DataType::Struct(fields)","class":"lineCov","hits":"1","order":"1644",},
{"lineNum":"  203","line":"                },"},
{"lineNum":"  204","line":"                DataType::Unknown,"},
{"lineNum":"  205","line":"            }"},
{"lineNum":"  206","line":"        };"},
{"lineNum":"  207","line":"        PolarsDataType(result.expect(\"Failure when unpacking an OCaml<DataType> variant into PolarsDataType (unexpected tag value\"))","class":"lineCov","hits":"1","order":"970",},
{"lineNum":"  208","line":"    }","class":"lineCov","hits":"1","order":"982",},
{"lineNum":"  209","line":"}"},
{"lineNum":"  210","line":""},
{"lineNum":"  211","line":"unsafe fn ocaml_value<T>(cr: &mut OCamlRuntime, n: i32) -> OCaml<T> {","class":"lineCov","hits":"1","order":"975",},
{"lineNum":"  212","line":"    unsafe { OCaml::new(cr, OCaml::of_i32(n).raw()) }","class":"lineCov","hits":"1","order":"955",},
{"lineNum":"  213","line":"}","class":"lineCov","hits":"1","order":"967",},
{"lineNum":"  214","line":""},
{"lineNum":"  215","line":"unsafe impl ToOCaml<DataType> for PolarsDataType {"},
{"lineNum":"  216","line":"    fn to_ocaml<\'a>(&self, cr: &\'a mut OCamlRuntime) -> OCaml<\'a, DataType> {","class":"lineCov","hits":"1","order":"983",},
{"lineNum":"  217","line":"        let PolarsDataType(datatype) = self;","class":"lineCov","hits":"1","order":"984",},
{"lineNum":"  218","line":"        // We expand out the macro here since we need to do some massaging of the"},
{"lineNum":"  219","line":"        // values to get things into the right shape to convert to OCaml values"},
{"lineNum":"  220","line":"        unsafe {"},
{"lineNum":"  221","line":"            match datatype {","class":"lineCov","hits":"1","order":"985",},
{"lineNum":"  222","line":"                DataType::Boolean => ocaml_value(cr, 0),","class":"lineCov","hits":"1","order":"1683",},
{"lineNum":"  223","line":"                DataType::UInt8 => ocaml_value(cr, 1),","class":"lineCov","hits":"1","order":"1684",},
{"lineNum":"  224","line":"                DataType::UInt16 => ocaml_value(cr, 2),","class":"lineCov","hits":"1","order":"1685",},
{"lineNum":"  225","line":"                DataType::UInt32 => ocaml_value(cr, 3),","class":"lineCov","hits":"1","order":"1686",},
{"lineNum":"  226","line":"                DataType::UInt64 => ocaml_value(cr, 4),","class":"lineCov","hits":"1","order":"1687",},
{"lineNum":"  227","line":"                DataType::Int8 => ocaml_value(cr, 5),","class":"lineCov","hits":"1","order":"1688",},
{"lineNum":"  228","line":"                DataType::Int16 => ocaml_value(cr, 6),","class":"lineCov","hits":"1","order":"1689",},
{"lineNum":"  229","line":"                DataType::Int32 => ocaml_value(cr, 7),","class":"lineCov","hits":"1","order":"1690",},
{"lineNum":"  230","line":"                DataType::Int64 => ocaml_value(cr, 8),","class":"lineCov","hits":"1","order":"988",},
{"lineNum":"  231","line":"                DataType::Float32 => ocaml_value(cr, 9),","class":"lineCov","hits":"1","order":"1691",},
{"lineNum":"  232","line":"                DataType::Float64 => ocaml_value(cr, 10),","class":"lineCov","hits":"1","order":"1692",},
{"lineNum":"  233","line":"                DataType::Utf8 => ocaml_value(cr, 11),","class":"lineCov","hits":"1","order":"989",},
{"lineNum":"  234","line":"                DataType::Binary => ocaml_value(cr, 12),","class":"lineCov","hits":"1","order":"1693",},
{"lineNum":"  235","line":"                DataType::Date => ocaml_value(cr, 13),","class":"lineCov","hits":"1","order":"1694",},
{"lineNum":"  236","line":"                DataType::Datetime(timeunit, timezone) => {","class":"lineCov","hits":"1","order":"1695",},
{"lineNum":"  237","line":"                    let timeunit = PolarsTimeUnit(*timeunit);","class":"lineCov","hits":"1","order":"1661",},
{"lineNum":"  238","line":"                    let timezone = timezone.clone();","class":"lineCov","hits":"1","order":"1650",},
{"lineNum":"  239","line":"                    ocaml_alloc_tagged_block!(cr, 0, timeunit: TimeUnit, timezone: Option<String>)","class":"lineCov","hits":"1","order":"1696",},
{"lineNum":"  240","line":"                }","class":"lineCov","hits":"1","order":"1637",},
{"lineNum":"  241","line":"                DataType::Duration(timeunit) => {","class":"lineCov","hits":"1","order":"1633",},
{"lineNum":"  242","line":"                    let timeunit = PolarsTimeUnit(*timeunit);","class":"lineCov","hits":"1","order":"1653",},
{"lineNum":"  243","line":"                    ocaml_alloc_tagged_block!(cr, 1, timeunit: TimeUnit)","class":"lineCov","hits":"1","order":"1697",},
{"lineNum":"  244","line":"                }"},
{"lineNum":"  245","line":"                DataType::Time => ocaml_value(cr, 14),","class":"lineCov","hits":"1","order":"1623",},
{"lineNum":"  246","line":"                DataType::List(datatype) => {","class":"lineCov","hits":"1","order":"1698",},
{"lineNum":"  247","line":"                    let datatype = PolarsDataType(*datatype.clone());","class":"lineCov","hits":"1","order":"1699",},
{"lineNum":"  248","line":"                    ocaml_alloc_tagged_block!(cr, 2, datatype: DataType)","class":"lineCov","hits":"1","order":"1701",},
{"lineNum":"  249","line":"                }","class":"lineCov","hits":"1","order":"1622",},
{"lineNum":"  250","line":"                DataType::Null => ocaml_value(cr, 15),","class":"lineCov","hits":"1","order":"1621",},
{"lineNum":"  251","line":"                DataType::Struct(fields) => {","class":"lineCov","hits":"1","order":"1700",},
{"lineNum":"  252","line":"                    let fields: Vec<(String, PolarsDataType)> = fields","class":"lineCov","hits":"1","order":"1620",},
{"lineNum":"  253","line":"                        .iter()"},
{"lineNum":"  254","line":"                        .map(|field| (field.name.to_string(), PolarsDataType(field.dtype.clone())))","class":"lineCov","hits":"1","order":"1619",},
{"lineNum":"  255","line":"                        .collect();"},
{"lineNum":"  256","line":"                    ocaml_alloc_tagged_block!(cr, 3, fields: OCamlList<(String, DataType)>)","class":"lineCov","hits":"1","order":"1618",},
{"lineNum":"  257","line":"                }","class":"lineCov","hits":"1","order":"1702",},
{"lineNum":"  258","line":"                DataType::Unknown => ocaml_value(cr, 16),","class":"lineCov","hits":"1","order":"1615",},
{"lineNum":"  259","line":"            }"},
{"lineNum":"  260","line":"        }"},
{"lineNum":"  261","line":"    }","class":"lineCov","hits":"1","order":"990",},
{"lineNum":"  262","line":"}"},
{"lineNum":"  263","line":""},
{"lineNum":"  264","line":"#[derive(Debug)]"},
{"lineNum":"  265","line":"pub enum GADTDataType {"},
{"lineNum":"  266","line":"    Boolean,"},
{"lineNum":"  267","line":"    UInt8,"},
{"lineNum":"  268","line":"    UInt16,"},
{"lineNum":"  269","line":"    UInt32,"},
{"lineNum":"  270","line":"    UInt64,"},
{"lineNum":"  271","line":"    Int8,"},
{"lineNum":"  272","line":"    Int16,"},
{"lineNum":"  273","line":"    Int32,"},
{"lineNum":"  274","line":"    Int64,"},
{"lineNum":"  275","line":"    Float32,"},
{"lineNum":"  276","line":"    Float64,"},
{"lineNum":"  277","line":"    Utf8,"},
{"lineNum":"  278","line":"    Binary,"},
{"lineNum":"  279","line":"    List(Box<GADTDataType>),"},
{"lineNum":"  280","line":"}"},
{"lineNum":"  281","line":""},
{"lineNum":"  282","line":"impl_from_ocaml_variant! {"},
{"lineNum":"  283","line":"    GADTDataType {"},
{"lineNum":"  284","line":"        GADTDataType::Boolean,"},
{"lineNum":"  285","line":"        GADTDataType::UInt8,"},
{"lineNum":"  286","line":"        GADTDataType::UInt16,"},
{"lineNum":"  287","line":"        GADTDataType::UInt32,"},
{"lineNum":"  288","line":"        GADTDataType::UInt64,"},
{"lineNum":"  289","line":"        GADTDataType::Int8,"},
{"lineNum":"  290","line":"        GADTDataType::Int16,"},
{"lineNum":"  291","line":"        GADTDataType::Int32,"},
{"lineNum":"  292","line":"        GADTDataType::Int64,"},
{"lineNum":"  293","line":"        GADTDataType::Float32,"},
{"lineNum":"  294","line":"        GADTDataType::Float64,"},
{"lineNum":"  295","line":"        GADTDataType::Utf8,"},
{"lineNum":"  296","line":"        GADTDataType::Binary,"},
{"lineNum":"  297","line":"        GADTDataType::List(data_type: GADTDataType),"},
{"lineNum":"  298","line":"    }"},
{"lineNum":"  299","line":"}"},
{"lineNum":"  300","line":""},
{"lineNum":"  301","line":"impl GADTDataType {"},
{"lineNum":"  302","line":"    pub fn to_data_type(&self) -> DataType {","class":"lineCov","hits":"1","order":"1614",},
{"lineNum":"  303","line":"        match self {","class":"lineCov","hits":"1","order":"1613",},
{"lineNum":"  304","line":"            GADTDataType::Boolean => DataType::Boolean,","class":"lineCov","hits":"1","order":"1666",},
{"lineNum":"  305","line":"            GADTDataType::UInt8 => DataType::UInt8,","class":"lineCov","hits":"1","order":"1612",},
{"lineNum":"  306","line":"            GADTDataType::UInt16 => DataType::UInt16,","class":"lineCov","hits":"1","order":"1611",},
{"lineNum":"  307","line":"            GADTDataType::UInt32 => DataType::UInt32,","class":"lineCov","hits":"1","order":"1609",},
{"lineNum":"  308","line":"            GADTDataType::UInt64 => DataType::UInt64,","class":"lineCov","hits":"1","order":"1630",},
{"lineNum":"  309","line":"            GADTDataType::Int8 => DataType::Int8,","class":"lineCov","hits":"1","order":"1629",},
{"lineNum":"  310","line":"            GADTDataType::Int16 => DataType::Int16,","class":"lineCov","hits":"1","order":"1703",},
{"lineNum":"  311","line":"            GADTDataType::Int32 => DataType::Int32,","class":"lineCov","hits":"1","order":"1704",},
{"lineNum":"  312","line":"            GADTDataType::Int64 => DataType::Int64,","class":"lineCov","hits":"1","order":"1610",},
{"lineNum":"  313","line":"            GADTDataType::Float32 => DataType::Float32,","class":"lineCov","hits":"1","order":"1705",},
{"lineNum":"  314","line":"            GADTDataType::Float64 => DataType::Float64,","class":"lineCov","hits":"1","order":"1706",},
{"lineNum":"  315","line":"            GADTDataType::Utf8 => DataType::Utf8,","class":"lineCov","hits":"1","order":"1707",},
{"lineNum":"  316","line":"            GADTDataType::Binary => DataType::Binary,","class":"lineCov","hits":"1","order":"1708",},
{"lineNum":"  317","line":"            GADTDataType::List(data_type) => DataType::List(Box::new(data_type.to_data_type())),","class":"lineCov","hits":"1","order":"1709",},
{"lineNum":"  318","line":"        }"},
{"lineNum":"  319","line":"    }","class":"lineCov","hits":"1","order":"1710",},
{"lineNum":"  320","line":"}"},
{"lineNum":"  321","line":""},
{"lineNum":"  322","line":"pub struct PolarsFillNullStrategy(pub FillNullStrategy);"},
{"lineNum":"  323","line":""},
{"lineNum":"  324","line":"unsafe impl FromOCaml<FillNullStrategy> for PolarsFillNullStrategy {"},
{"lineNum":"  325","line":"    fn from_ocaml(v: OCaml<FillNullStrategy>) -> Self {","class":"lineCov","hits":"1","order":"991",},
{"lineNum":"  326","line":"        let result = ocaml_unpack_variant! {","class":"lineCov","hits":"1","order":"959",},
{"lineNum":"  327","line":"            v => {"},
{"lineNum":"  328","line":"                FillNullStrategy::Backward(upto: Option<OCamlInt>) => {"},
{"lineNum":"  329","line":"                    let upto_: Option<i64> = upto;","class":"lineCov","hits":"1","order":"1655",},
{"lineNum":"  330","line":"                    let upto: Option<Option<u32>> = upto_.map(|upto| TryInto::<u32>::try_into(upto).ok());","class":"lineCov","hits":"1","order":"1656",},
{"lineNum":"  331","line":"                    match upto {","class":"lineCov","hits":"1","order":"1658",},
{"lineNum":"  332","line":"                        None => FillNullStrategy::Backward(None),","class":"lineCov","hits":"1","order":"1641",},
{"lineNum":"  333","line":"                        Some(None) => unsafe { ocaml_failwith(&format!(\"Failed conversion to u32 {:?}\", upto_)) },","class":"lineCov","hits":"1","order":"1673",},
{"lineNum":"  334","line":"                        Some(upto) => FillNullStrategy::Backward(upto),","class":"lineCov","hits":"1","order":"1626",},
{"lineNum":"  335","line":"                    }"},
{"lineNum":"  336","line":"                },"},
{"lineNum":"  337","line":"                FillNullStrategy::Forward(upto: Option<OCamlInt>) => {"},
{"lineNum":"  338","line":"                    let upto_: Option<i64> = upto;","class":"lineCov","hits":"1","order":"939",},
{"lineNum":"  339","line":"                    let upto: Option<Option<u32>> = upto_.map(|upto| TryInto::<u32>::try_into(upto).ok());","class":"lineCov","hits":"1","order":"954",},
{"lineNum":"  340","line":"                    match upto {","class":"lineCov","hits":"1","order":"944",},
{"lineNum":"  341","line":"                        None => FillNullStrategy::Forward(None),","class":"lineCov","hits":"1","order":"938",},
{"lineNum":"  342","line":"                        Some(None) => unsafe { ocaml_failwith(&format!(\"Failed conversion to u32 {:?}\", upto_)) },","class":"lineCov","hits":"1","order":"1643",},
{"lineNum":"  343","line":"                        Some(upto) => FillNullStrategy::Forward(upto),","class":"lineCov","hits":"1","order":"1645",},
{"lineNum":"  344","line":"                    }"},
{"lineNum":"  345","line":"                },"},
{"lineNum":"  346","line":"                FillNullStrategy::Mean,"},
{"lineNum":"  347","line":"                FillNullStrategy::Min,"},
{"lineNum":"  348","line":"                FillNullStrategy::Max,"},
{"lineNum":"  349","line":"                FillNullStrategy::Zero,"},
{"lineNum":"  350","line":"                FillNullStrategy::One,"},
{"lineNum":"  351","line":"                FillNullStrategy::MaxBound,"},
{"lineNum":"  352","line":"                FillNullStrategy::MinBound,"},
{"lineNum":"  353","line":"            }"},
{"lineNum":"  354","line":"        };"},
{"lineNum":"  355","line":"        PolarsFillNullStrategy(result.expect(\"Failure when unpacking an OCaml<FillNullStrategy> variant into PolarsFillNullStrategy (unexpected tag value\"))","class":"lineCov","hits":"1","order":"992",},
{"lineNum":"  356","line":"    }","class":"lineCov","hits":"1","order":"914",},
{"lineNum":"  357","line":"}"},
{"lineNum":"  358","line":""},
{"lineNum":"  359","line":"unsafe impl ToOCaml<FillNullStrategy> for PolarsFillNullStrategy {"},
{"lineNum":"  360","line":"    fn to_ocaml<\'a>(&self, cr: &\'a mut OCamlRuntime) -> OCaml<\'a, FillNullStrategy> {","class":"lineCov","hits":"1","order":"1649",},
{"lineNum":"  361","line":"        let PolarsFillNullStrategy(fill_null_strategy) = self;","class":"lineCov","hits":"1","order":"1606",},
{"lineNum":"  362","line":""},
{"lineNum":"  363","line":"        // We expand out the macro here since we need to do some massaging of the"},
{"lineNum":"  364","line":"        // values to get things into the right shape to convert to OCaml values"},
{"lineNum":"  365","line":"        unsafe {"},
{"lineNum":"  366","line":"            match fill_null_strategy {","class":"lineCov","hits":"1","order":"1660",},
{"lineNum":"  367","line":"                FillNullStrategy::Backward(upto) => {","class":"lineCov","hits":"1","order":"1639",},
{"lineNum":"  368","line":"                    let upto = upto.map(|upto| upto as i64);","class":"lineCov","hits":"1","order":"1635",},
{"lineNum":"  369","line":"                    ocaml_alloc_tagged_block!(cr, 0, upto: Option<OCamlInt>)","class":"lineCov","hits":"1","order":"1711",},
{"lineNum":"  370","line":"                }"},
{"lineNum":"  371","line":"                FillNullStrategy::Forward(upto) => {","class":"lineCov","hits":"1","order":"1712",},
{"lineNum":"  372","line":"                    let upto = upto.map(|upto| upto as i64);","class":"lineCov","hits":"1","order":"1654",},
{"lineNum":"  373","line":"                    ocaml_alloc_tagged_block!(cr, 1, upto: Option<OCamlInt>)","class":"lineCov","hits":"1","order":"1713",},
{"lineNum":"  374","line":"                }"},
{"lineNum":"  375","line":"                FillNullStrategy::Mean => ocaml_value(cr, 0),","class":"lineCov","hits":"1","order":"1636",},
{"lineNum":"  376","line":"                FillNullStrategy::Min => ocaml_value(cr, 1),","class":"lineCov","hits":"1","order":"1714",},
{"lineNum":"  377","line":"                FillNullStrategy::Max => ocaml_value(cr, 2),","class":"lineCov","hits":"1","order":"1675",},
{"lineNum":"  378","line":"                FillNullStrategy::Zero => ocaml_value(cr, 3),","class":"lineCov","hits":"1","order":"1676",},
{"lineNum":"  379","line":"                FillNullStrategy::One => ocaml_value(cr, 4),","class":"lineCov","hits":"1","order":"1715",},
{"lineNum":"  380","line":"                FillNullStrategy::MaxBound => ocaml_value(cr, 5),","class":"lineCov","hits":"1","order":"1716",},
{"lineNum":"  381","line":"                FillNullStrategy::MinBound => ocaml_value(cr, 6),","class":"lineCov","hits":"1","order":"1718",},
{"lineNum":"  382","line":"            }"},
{"lineNum":"  383","line":"        }"},
{"lineNum":"  384","line":"    }","class":"lineCov","hits":"1","order":"1608",},
{"lineNum":"  385","line":"}"},
{"lineNum":"  386","line":""},
{"lineNum":"  387","line":"pub struct PolarsInterpolationMethod(pub InterpolationMethod);"},
{"lineNum":"  388","line":""},
{"lineNum":"  389","line":"unsafe impl FromOCaml<InterpolationMethod> for PolarsInterpolationMethod {"},
{"lineNum":"  390","line":"    fn from_ocaml(v: OCaml<InterpolationMethod>) -> Self {","class":"lineCov","hits":"1","order":"993",},
{"lineNum":"  391","line":"        let result = ocaml_unpack_polymorphic_variant! {","class":"lineCov","hits":"1","order":"994",},
{"lineNum":"  392","line":"            v => {"},
{"lineNum":"  393","line":"                Linear => InterpolationMethod::Linear,","class":"lineCov","hits":"1","order":"928",},
{"lineNum":"  394","line":"                Nearest => InterpolationMethod::Nearest,","class":"lineNoCov","hits":"0",},
{"lineNum":"  395","line":"            }"},
{"lineNum":"  396","line":"        };"},
{"lineNum":"  397","line":"        PolarsInterpolationMethod(result.expect(\"Failure when unpacking an OCaml<InterpolationMethod> variant into PolarsInterpolationMethod (unexpected tag value\"))","class":"lineCov","hits":"1","order":"941",},
{"lineNum":"  398","line":"    }","class":"lineCov","hits":"1","order":"995",},
{"lineNum":"  399","line":"}"},
{"lineNum":"  400","line":""},
{"lineNum":"  401","line":"unsafe impl ToOCaml<InterpolationMethod> for PolarsInterpolationMethod {"},
{"lineNum":"  402","line":"    fn to_ocaml<\'a>(&self, cr: &\'a mut OCamlRuntime) -> OCaml<\'a, InterpolationMethod> {"},
{"lineNum":"  403","line":"        let PolarsInterpolationMethod(interpolation_method) = self;"},
{"lineNum":"  404","line":""},
{"lineNum":"  405","line":"        ocaml_alloc_polymorphic_variant! {"},
{"lineNum":"  406","line":"            cr, interpolation_method => {"},
{"lineNum":"  407","line":"                InterpolationMethod::Linear,"},
{"lineNum":"  408","line":"                InterpolationMethod::Nearest,"},
{"lineNum":"  409","line":"            }"},
{"lineNum":"  410","line":"        }"},
{"lineNum":"  411","line":"    }"},
{"lineNum":"  412","line":"}"},
{"lineNum":"  413","line":""},
{"lineNum":"  414","line":"pub struct PolarsWindowMapping(pub WindowMapping);"},
{"lineNum":"  415","line":""},
{"lineNum":"  416","line":"unsafe impl FromOCaml<WindowMapping> for PolarsWindowMapping {"},
{"lineNum":"  417","line":"    fn from_ocaml(v: OCaml<WindowMapping>) -> Self {","class":"lineNoCov","hits":"0",},
{"lineNum":"  418","line":"        let result = ocaml_unpack_polymorphic_variant! {","class":"lineNoCov","hits":"0",},
{"lineNum":"  419","line":"            v => {"},
{"lineNum":"  420","line":"                Groups_to_rows => WindowMapping::GroupsToRows,","class":"lineNoCov","hits":"0",},
{"lineNum":"  421","line":"                Explode => WindowMapping::Explode,","class":"lineNoCov","hits":"0",},
{"lineNum":"  422","line":"                Join => WindowMapping::Join,","class":"lineNoCov","hits":"0",},
{"lineNum":"  423","line":"            }"},
{"lineNum":"  424","line":"        };"},
{"lineNum":"  425","line":"        PolarsWindowMapping(result.expect(\"Failure when unpacking an OCaml<WindowMapping> variant into PolarsWindowMapping (unexpected tag value\"))","class":"lineNoCov","hits":"0",},
{"lineNum":"  426","line":"    }","class":"lineNoCov","hits":"0",},
{"lineNum":"  427","line":"}"},
{"lineNum":"  428","line":""},
{"lineNum":"  429","line":"unsafe impl ToOCaml<WindowMapping> for PolarsWindowMapping {"},
{"lineNum":"  430","line":"    fn to_ocaml<\'a>(&self, cr: &\'a mut OCamlRuntime) -> OCaml<\'a, WindowMapping> {"},
{"lineNum":"  431","line":"        let PolarsWindowMapping(window_mapping) = self;"},
{"lineNum":"  432","line":""},
{"lineNum":"  433","line":"        unsafe {"},
{"lineNum":"  434","line":"            match window_mapping {"},
{"lineNum":"  435","line":"                WindowMapping::GroupsToRows => {"},
{"lineNum":"  436","line":"                    OCaml::new(cr, polymorphic_variant_tag_hash!(Groups_to_rows))"},
{"lineNum":"  437","line":"                }"},
{"lineNum":"  438","line":"                WindowMapping::Explode => OCaml::new(cr, polymorphic_variant_tag_hash!(Explode)),"},
{"lineNum":"  439","line":"                WindowMapping::Join => OCaml::new(cr, polymorphic_variant_tag_hash!(Join)),"},
{"lineNum":"  440","line":"            }"},
{"lineNum":"  441","line":"        }"},
{"lineNum":"  442","line":"    }"},
{"lineNum":"  443","line":"}"},
{"lineNum":"  444","line":""},
{"lineNum":"  445","line":"pub struct PolarsRankMethod(pub RankMethod);"},
{"lineNum":"  446","line":""},
{"lineNum":"  447","line":"unsafe impl FromOCaml<RankMethod> for PolarsRankMethod {"},
{"lineNum":"  448","line":"    fn from_ocaml(v: OCaml<RankMethod>) -> Self {","class":"lineCov","hits":"1","order":"972",},
{"lineNum":"  449","line":"        let result = ocaml_unpack_polymorphic_variant! {","class":"lineCov","hits":"1","order":"973",},
{"lineNum":"  450","line":"            v => {"},
{"lineNum":"  451","line":"                Average => RankMethod::Average,","class":"lineNoCov","hits":"0",},
{"lineNum":"  452","line":"                Min => RankMethod::Min,","class":"lineNoCov","hits":"0",},
{"lineNum":"  453","line":"                Max => RankMethod::Max,","class":"lineNoCov","hits":"0",},
{"lineNum":"  454","line":"                Dense => RankMethod::Dense,","class":"lineCov","hits":"1","order":"930",},
{"lineNum":"  455","line":"                Ordinal => RankMethod::Ordinal,","class":"lineNoCov","hits":"0",},
{"lineNum":"  456","line":"                Random => RankMethod::Random,","class":"lineNoCov","hits":"0",},
{"lineNum":"  457","line":"            }"},
{"lineNum":"  458","line":"        };"},
{"lineNum":"  459","line":"        PolarsRankMethod(result.expect(\"Failure when unpacking an OCaml<RankMethod> variant into PolarsRankMethod (unexpected tag value\"))","class":"lineCov","hits":"1","order":"943",},
{"lineNum":"  460","line":"    }","class":"lineCov","hits":"1","order":"996",},
{"lineNum":"  461","line":"}"},
{"lineNum":"  462","line":""},
{"lineNum":"  463","line":"unsafe impl ToOCaml<RankMethod> for PolarsRankMethod {"},
{"lineNum":"  464","line":"    fn to_ocaml<\'a>(&self, cr: &\'a mut OCamlRuntime) -> OCaml<\'a, RankMethod> {"},
{"lineNum":"  465","line":"        let PolarsRankMethod(rank_method) = self;"},
{"lineNum":"  466","line":"        ocaml_alloc_polymorphic_variant! {"},
{"lineNum":"  467","line":"            cr, rank_method => {"},
{"lineNum":"  468","line":"                RankMethod::Average,"},
{"lineNum":"  469","line":"                RankMethod::Min,"},
{"lineNum":"  470","line":"                RankMethod::Max,"},
{"lineNum":"  471","line":"                RankMethod::Dense,"},
{"lineNum":"  472","line":"                RankMethod::Ordinal,"},
{"lineNum":"  473","line":"                RankMethod::Random,"},
{"lineNum":"  474","line":"            }"},
{"lineNum":"  475","line":"        }"},
{"lineNum":"  476","line":"    }"},
{"lineNum":"  477","line":"}"},
{"lineNum":"  478","line":""},
{"lineNum":"  479","line":"pub struct PolarsJoinType(pub JoinType);"},
{"lineNum":"  480","line":"unsafe impl FromOCaml<JoinType> for PolarsJoinType {"},
{"lineNum":"  481","line":"    fn from_ocaml(v: OCaml<JoinType>) -> Self {","class":"lineCov","hits":"1","order":"986",},
{"lineNum":"  482","line":"        let result = ocaml_unpack_variant! {","class":"lineCov","hits":"1","order":"987",},
{"lineNum":"  483","line":"            v => {"},
{"lineNum":"  484","line":"                JoinType::Left,"},
{"lineNum":"  485","line":"                JoinType::Inner,"},
{"lineNum":"  486","line":"                JoinType::Outer,"},
{"lineNum":"  487","line":"                JoinType::AsOf(dummy: ()) => {"},
{"lineNum":"  488","line":"                    // We don\'t actually care about the value of dummy, we just"},
{"lineNum":"  489","line":"                    // need to make sure that the variant is treated as a"},
{"lineNum":"  490","line":"                    // block, not a value."},
{"lineNum":"  491","line":"                    let () = dummy;"},
{"lineNum":"  492","line":""},
{"lineNum":"  493","line":"                    unsafe {"},
{"lineNum":"  494","line":"                        let strategy = v.field::<AsofStrategy>(0);","class":"lineCov","hits":"1","order":"966",},
{"lineNum":"  495","line":"                        let strategy = ocaml_unpack_polymorphic_variant! {","class":"lineCov","hits":"1","order":"949",},
{"lineNum":"  496","line":"                            strategy => {"},
{"lineNum":"  497","line":"                                Backward => AsofStrategy::Backward,","class":"lineCov","hits":"1","order":"936",},
{"lineNum":"  498","line":"                                Forward => AsofStrategy::Forward,","class":"lineCov","hits":"1","order":"1632",},
{"lineNum":"  499","line":"                                Nearest => AsofStrategy::Nearest,","class":"lineCov","hits":"1","order":"1652",},
{"lineNum":"  500","line":"                            }"},
{"lineNum":"  501","line":"                        };"},
{"lineNum":"  502","line":"                        let strategy = strategy.expect(","class":"lineCov","hits":"1","order":"924",},
{"lineNum":"  503","line":"                            \"Failure when unpacking an OCaml<AsofStrategy> variant (unexpected tag value\","},
{"lineNum":"  504","line":"                        );"},
{"lineNum":"  505","line":""},
{"lineNum":"  506","line":"                        let tolerance: Option<String> = v.field::<Option<String>>(1).to_rust();","class":"lineCov","hits":"1","order":"923",},
{"lineNum":"  507","line":"                        let tolerance = tolerance.map(SmartString::from);","class":"lineCov","hits":"1","order":"922",},
{"lineNum":"  508","line":""},
{"lineNum":"  509","line":"                        let left_by: Option<Vec<String>> = v.field::<Option<OCamlList<String>>>(2).to_rust();","class":"lineCov","hits":"1","order":"921",},
{"lineNum":"  510","line":"                        let left_by: Option<Vec<SmartString<LazyCompact>>> ="},
{"lineNum":"  511","line":"                            left_by.map(|left_by| left_by.into_iter().map(SmartString::from).collect());","class":"lineCov","hits":"1","order":"920",},
{"lineNum":"  512","line":""},
{"lineNum":"  513","line":"                        let right_by: Option<Vec<String>> = v.field::<Option<OCamlList<String>>>(3).to_rust();","class":"lineCov","hits":"1","order":"919",},
{"lineNum":"  514","line":"                        let right_by: Option<Vec<SmartString<LazyCompact>>> ="},
{"lineNum":"  515","line":"                            right_by.map(|right_by| right_by.into_iter().map(SmartString::from).collect());","class":"lineCov","hits":"1","order":"918",},
{"lineNum":"  516","line":""},
{"lineNum":"  517","line":"                        JoinType::AsOf(AsOfOptions {","class":"lineCov","hits":"1","order":"915",},
{"lineNum":"  518","line":"                            strategy,"},
{"lineNum":"  519","line":"                            tolerance: None,","class":"lineCov","hits":"1","order":"917",},
{"lineNum":"  520","line":"                            tolerance_str: tolerance,","class":"lineCov","hits":"1","order":"927",},
{"lineNum":"  521","line":"                            left_by,","class":"lineCov","hits":"1","order":"926",},
{"lineNum":"  522","line":"                            right_by,","class":"lineCov","hits":"1","order":"916",},
{"lineNum":"  523","line":"                        })"},
{"lineNum":"  524","line":"                    }","class":"lineNoCov","hits":"0",},
{"lineNum":"  525","line":"                },"},
{"lineNum":"  526","line":"                JoinType::Cross,"},
{"lineNum":"  527","line":"                JoinType::Semi,"},
{"lineNum":"  528","line":"                JoinType::Anti,"},
{"lineNum":"  529","line":"            }"},
{"lineNum":"  530","line":"        };"},
{"lineNum":"  531","line":""},
{"lineNum":"  532","line":"        PolarsJoinType(result.expect(\"Failure when unpacking an OCaml<JoinType> variant into PolarsJoinType (unexpected tag value\"))","class":"lineCov","hits":"1","order":"997",},
{"lineNum":"  533","line":"    }","class":"lineCov","hits":"1","order":"998",},
{"lineNum":"  534","line":"}"},
{"lineNum":"  535","line":""},
{"lineNum":"  536","line":"pub struct PolarsClosedWindow(pub ClosedWindow);"},
{"lineNum":"  537","line":""},
{"lineNum":"  538","line":"unsafe impl FromOCaml<ClosedWindow> for PolarsClosedWindow {"},
{"lineNum":"  539","line":"    fn from_ocaml(v: OCaml<ClosedWindow>) -> Self {","class":"lineNoCov","hits":"0",},
{"lineNum":"  540","line":"        let result = ocaml_unpack_polymorphic_variant! {","class":"lineNoCov","hits":"0",},
{"lineNum":"  541","line":"            v => {"},
{"lineNum":"  542","line":"                Left => ClosedWindow::Left,","class":"lineNoCov","hits":"0",},
{"lineNum":"  543","line":"                Right => ClosedWindow::Right,","class":"lineNoCov","hits":"0",},
{"lineNum":"  544","line":"                Both => ClosedWindow::Both,","class":"lineNoCov","hits":"0",},
{"lineNum":"  545","line":"                None_ => ClosedWindow::None,","class":"lineNoCov","hits":"0",},
{"lineNum":"  546","line":"            }"},
{"lineNum":"  547","line":"        };"},
{"lineNum":"  548","line":"        PolarsClosedWindow(result.expect(\"Failure when unpacking an OCaml<ClosedWindow> variant into PolarsClosedWindow (unexpected tag value\"))","class":"lineNoCov","hits":"0",},
{"lineNum":"  549","line":"    }","class":"lineNoCov","hits":"0",},
{"lineNum":"  550","line":"}"},
{"lineNum":"  551","line":""},
{"lineNum":"  552","line":"pub struct PolarsStartBy(pub StartBy);"},
{"lineNum":"  553","line":""},
{"lineNum":"  554","line":"unsafe impl FromOCaml<StartBy> for PolarsStartBy {"},
{"lineNum":"  555","line":"    fn from_ocaml(v: OCaml<StartBy>) -> Self {","class":"lineNoCov","hits":"0",},
{"lineNum":"  556","line":"        let result = ocaml_unpack_polymorphic_variant! {","class":"lineNoCov","hits":"0",},
{"lineNum":"  557","line":"            v => {"},
{"lineNum":"  558","line":"                Window_bound => StartBy::WindowBound,","class":"lineNoCov","hits":"0",},
{"lineNum":"  559","line":"                Data_point => StartBy::DataPoint,","class":"lineNoCov","hits":"0",},
{"lineNum":"  560","line":"                Monday => StartBy::Monday,","class":"lineNoCov","hits":"0",},
{"lineNum":"  561","line":"                Tuesday => StartBy::Tuesday,","class":"lineNoCov","hits":"0",},
{"lineNum":"  562","line":"                Wednesday => StartBy::Wednesday,","class":"lineNoCov","hits":"0",},
{"lineNum":"  563","line":"                Thursday => StartBy::Thursday,","class":"lineNoCov","hits":"0",},
{"lineNum":"  564","line":"                Friday => StartBy::Friday,","class":"lineNoCov","hits":"0",},
{"lineNum":"  565","line":"                Saturday => StartBy::Saturday,","class":"lineNoCov","hits":"0",},
{"lineNum":"  566","line":"                Sunday => StartBy::Sunday,","class":"lineNoCov","hits":"0",},
{"lineNum":"  567","line":"            }"},
{"lineNum":"  568","line":"        };"},
{"lineNum":"  569","line":"        PolarsStartBy(result.expect(\"Failure when unpacking an OCaml<StartBy> variant into PolarsStartBy (unexpected tag value\"))","class":"lineNoCov","hits":"0",},
{"lineNum":"  570","line":"    }","class":"lineNoCov","hits":"0",},
{"lineNum":"  571","line":"}"},
{"lineNum":"  572","line":""},
{"lineNum":"  573","line":"// Coerce<OCamlType, Via, T>, given OCamlType which can be converted into a Rust"},
{"lineNum":"  574","line":"// type Via, will try_into() T and will raise an OCaml exception if the"},
{"lineNum":"  575","line":"// conversion fails. For example, Coerce<OCamlInt, i64, u32> will convert an"},
{"lineNum":"  576","line":"// OCamlInt into an i64 and then try to convert that i64 into a u32."},
{"lineNum":"  577","line":"pub struct Coerce<OCamlType, Via, T>("},
{"lineNum":"  578","line":"    pub Result<T, String>,"},
{"lineNum":"  579","line":"    pub PhantomData<Via>,"},
{"lineNum":"  580","line":"    pub PhantomData<OCamlType>,"},
{"lineNum":"  581","line":");"},
{"lineNum":"  582","line":"impl<OCamlType, Via, T> Coerce<OCamlType, Via, T> {"},
{"lineNum":"  583","line":"    pub fn get(self) -> Result<T, String> {","class":"lineCov","hits":"1","order":"958",},
{"lineNum":"  584","line":"        self.0","class":"lineCov","hits":"1","order":"960",},
{"lineNum":"  585","line":"    }","class":"lineCov","hits":"1","order":"962",},
{"lineNum":"  586","line":"}"},
{"lineNum":"  587","line":"unsafe impl<OCamlType, Via, T> FromOCaml<OCamlType> for Coerce<OCamlType, Via, T>"},
{"lineNum":"  588","line":"where"},
{"lineNum":"  589","line":"    Via: FromOCaml<OCamlType>,"},
{"lineNum":"  590","line":"    T: TryFrom<Via>,"},
{"lineNum":"  591","line":"    <T as TryFrom<Via>>::Error: std::fmt::Debug,"},
{"lineNum":"  592","line":"{"},
{"lineNum":"  593","line":"    fn from_ocaml(v: OCaml<OCamlType>) -> Self {","class":"lineCov","hits":"1","order":"956",},
{"lineNum":"  594","line":"        let try_into_result = T::try_from(v.to_rust::<Via>()).map_err(|e| {","class":"lineCov","hits":"1","order":"968",},
{"lineNum":"  595","line":"            format!(","class":"lineNoCov","hits":"0",},
{"lineNum":"  596","line":"                \"Failed to convert OCaml<{}> (from {}) to Rust<{}>: {:?}\","},
{"lineNum":"  597","line":"                type_name::<Via>(),","class":"lineNoCov","hits":"0",},
{"lineNum":"  598","line":"                type_name::<OCamlType>(),","class":"lineNoCov","hits":"0",},
{"lineNum":"  599","line":"                type_name::<T>(),","class":"lineNoCov","hits":"0",},
{"lineNum":"  600","line":"                e"},
{"lineNum":"  601","line":"            )"},
{"lineNum":"  602","line":"        });","class":"lineNoCov","hits":"0",},
{"lineNum":"  603","line":""},
{"lineNum":"  604","line":"        Coerce(try_into_result, PhantomData, PhantomData)","class":"lineCov","hits":"1","order":"950",},
{"lineNum":"  605","line":"    }","class":"lineCov","hits":"1","order":"945",},
{"lineNum":"  606","line":"}"},
{"lineNum":"  607","line":""},
{"lineNum":"  608","line":"unsafe impl<OCamlType, Via, T> FromOCaml<Option<OCamlType>>"},
{"lineNum":"  609","line":"    for Coerce<OCamlType, Option<Via>, Option<T>>"},
{"lineNum":"  610","line":"where"},
{"lineNum":"  611","line":"    Via: FromOCaml<OCamlType>,"},
{"lineNum":"  612","line":"    T: TryFrom<Via>,"},
{"lineNum":"  613","line":"    <T as TryFrom<Via>>::Error: std::fmt::Debug,"},
{"lineNum":"  614","line":"{"},
{"lineNum":"  615","line":"    fn from_ocaml(v: OCaml<Option<OCamlType>>) -> Self {","class":"lineCov","hits":"1","order":"935",},
{"lineNum":"  616","line":"        let try_into_result ="},
{"lineNum":"  617","line":"        match v.to_rust::<Option<Via>>() {","class":"lineCov","hits":"1","order":"948",},
{"lineNum":"  618","line":"            None => Ok(None),","class":"lineCov","hits":"1","order":"913",},
{"lineNum":"  619","line":"            Some(v) => match T::try_from(v) {","class":"lineCov","hits":"1","order":"951",},
{"lineNum":"  620","line":"                Ok(v) => Ok(Some(v)),","class":"lineCov","hits":"1","order":"912",},
{"lineNum":"  621","line":"                Err(e) => Err(format!(","class":"lineCov","hits":"1","order":"1664",},
{"lineNum":"  622","line":"                        \"Failed to convert OCaml<Option<{}>> (from Option<{}>) to Rust<Option<{}>>: {:?}\","},
{"lineNum":"  623","line":"                        type_name::<Via>(),","class":"lineCov","hits":"1","order":"1659",},
{"lineNum":"  624","line":"                        type_name::<OCamlType>(),","class":"lineCov","hits":"1","order":"1646",},
{"lineNum":"  625","line":"                        type_name::<T>(),","class":"lineCov","hits":"1","order":"1634",},
{"lineNum":"  626","line":"                        e"},
{"lineNum":"  627","line":"                    )),","class":"lineCov","hits":"1","order":"1663",},
{"lineNum":"  628","line":"            },"},
{"lineNum":"  629","line":"        };"},
{"lineNum":"  630","line":""},
{"lineNum":"  631","line":"        Coerce(try_into_result, PhantomData, PhantomData)","class":"lineCov","hits":"1","order":"952",},
{"lineNum":"  632","line":"    }","class":"lineCov","hits":"1","order":"934",},
{"lineNum":"  633","line":"}"},
{"lineNum":"  634","line":""},
{"lineNum":"  635","line":"pub struct PolarsIsSorted(pub IsSorted);"},
{"lineNum":"  636","line":"unsafe impl FromOCaml<IsSorted> for PolarsIsSorted {"},
{"lineNum":"  637","line":"    fn from_ocaml(v: OCaml<IsSorted>) -> Self {","class":"lineCov","hits":"1","order":"1717",},
{"lineNum":"  638","line":"        let result = ocaml_unpack_polymorphic_variant! {","class":"lineCov","hits":"1","order":"1719",},
{"lineNum":"  639","line":"            v => {"},
{"lineNum":"  640","line":"                Ascending => IsSorted::Ascending,","class":"lineCov","hits":"1","order":"1617",},
{"lineNum":"  641","line":"                Descending => IsSorted::Descending,","class":"lineNoCov","hits":"0",},
{"lineNum":"  642","line":"                Not => IsSorted::Not,","class":"lineNoCov","hits":"0",},
{"lineNum":"  643","line":"            }"},
{"lineNum":"  644","line":"        };"},
{"lineNum":"  645","line":""},
{"lineNum":"  646","line":"        PolarsIsSorted(result.expect(\"Failure when unpacking an OCaml<IsSorted> variant into PolarsIsSorted (unexpected tag value\"))","class":"lineCov","hits":"1","order":"1677",},
{"lineNum":"  647","line":"    }","class":"lineCov","hits":"1","order":"1721",},
{"lineNum":"  648","line":"}"},
{"lineNum":"  649","line":""},
{"lineNum":"  650","line":"pub struct Abstract<T>(pub T);","class":"lineCov","hits":"1","order":"929",},
{"lineNum":"  651","line":"unsafe impl<T: \'static + Clone> FromOCaml<DynBox<T>> for Abstract<T> {"},
{"lineNum":"  652","line":"    fn from_ocaml(v: OCaml<DynBox<T>>) -> Self {","class":"lineCov","hits":"1","order":"946",},
{"lineNum":"  653","line":"        Abstract(Borrow::<T>::borrow(&v).clone())","class":"lineCov","hits":"1","order":"964",},
{"lineNum":"  654","line":"    }","class":"lineCov","hits":"1","order":"940",},
{"lineNum":"  655","line":"}"},
{"lineNum":"  656","line":""},
{"lineNum":"  657","line":"unsafe impl<T: \'static + Clone> ToOCaml<DynBox<T>> for Abstract<T> {"},
{"lineNum":"  658","line":"    fn to_ocaml<\'a>(&self, cr: &\'a mut OCamlRuntime) -> OCaml<\'a, DynBox<T>> {","class":"lineCov","hits":"1","order":"953",},
{"lineNum":"  659","line":"        // TODO: I don\'t fully understand why ToOCaml takes a &self, since that"},
{"lineNum":"  660","line":"        // prevents us from using box_value without a clone() call."},
{"lineNum":"  661","line":"        OCaml::box_value(cr, self.0.clone())","class":"lineCov","hits":"1","order":"977",},
{"lineNum":"  662","line":"    }","class":"lineCov","hits":"1","order":"978",},
{"lineNum":"  663","line":"}"},
{"lineNum":"  664","line":""},
{"lineNum":"  665","line":"// TODO: perhaps ocaml_interop can expose the underlying boxroot value"},
{"lineNum":"  666","line":"// (along with BoxRoot::new()), so that we don\'t need to lie and can just use"},
{"lineNum":"  667","line":"// that?"},
{"lineNum":"  668","line":""},
{"lineNum":"  669","line":"// DummyBoxRoot represents a value BoxRoot<T> which has been coerced into a"},
{"lineNum":"  670","line":"// BoxRoot<DummyBoxRoot>. This explicitly circumvents the type safety provided"},
{"lineNum":"  671","line":"// by ocaml_interop\'s types, but is necessary if we want to take or return"},
{"lineNum":"  672","line":"// values with types which are dependent on GADT arguments."},
{"lineNum":"  673","line":"pub struct DummyBoxRoot(BoxRoot<DummyBoxRoot>);"},
{"lineNum":"  674","line":""},
{"lineNum":"  675","line":"unsafe impl FromOCaml<DummyBoxRoot> for DummyBoxRoot {"},
{"lineNum":"  676","line":"    fn from_ocaml(v: OCaml<DummyBoxRoot>) -> Self {","class":"lineCov","hits":"1","order":"999",},
{"lineNum":"  677","line":"        DummyBoxRoot(v.root())","class":"lineCov","hits":"1","order":"911",},
{"lineNum":"  678","line":"    }","class":"lineCov","hits":"1","order":"910",},
{"lineNum":"  679","line":"}"},
{"lineNum":"  680","line":""},
{"lineNum":"  681","line":"unsafe impl ToOCaml<DummyBoxRoot> for DummyBoxRoot {"},
{"lineNum":"  682","line":"    fn to_ocaml<\'a>(&self, cr: &\'a mut OCamlRuntime) -> OCaml<\'a, DummyBoxRoot> {","class":"lineCov","hits":"1","order":"1604",},
{"lineNum":"  683","line":"        self.0.get(cr)","class":"lineCov","hits":"1","order":"1603",},
{"lineNum":"  684","line":"    }","class":"lineCov","hits":"1","order":"1602",},
{"lineNum":"  685","line":"}"},
{"lineNum":"  686","line":""},
{"lineNum":"  687","line":"impl DummyBoxRoot {"},
{"lineNum":"  688","line":"    pub unsafe fn new<T>(boxroot: BoxRoot<T>) -> Self {","class":"lineCov","hits":"1","order":"1667",},
{"lineNum":"  689","line":"        // It\'s quite unfortunate that we have to transmute here. Ideally we"},
{"lineNum":"  690","line":"        // would coerce the type like we do in `interpret` below, but there is"},
{"lineNum":"  691","line":"        // no such interface for BoxRoots so we can\'t do that."},
{"lineNum":"  692","line":"        //"},
{"lineNum":"  693","line":"        // The type here is a phantom type so transmute (hopefully) should be safe."},
{"lineNum":"  694","line":"        let boxroot: BoxRoot<DummyBoxRoot> = std::mem::transmute(boxroot);","class":"lineCov","hits":"1","order":"1680",},
{"lineNum":"  695","line":""},
{"lineNum":"  696","line":"        DummyBoxRoot(boxroot)","class":"lineCov","hits":"1","order":"1668",},
{"lineNum":"  697","line":"    }","class":"lineCov","hits":"1","order":"1669",},
{"lineNum":"  698","line":""},
{"lineNum":"  699","line":"    pub fn interpret<\'a, T>(&self, cr: &\'a OCamlRuntime) -> OCaml<\'a, T> {","class":"lineCov","hits":"1","order":"932",},
{"lineNum":"  700","line":"        let ocaml_value: OCaml<DummyBoxRoot> = self.0.get(cr);","class":"lineCov","hits":"1","order":"974",},
{"lineNum":"  701","line":""},
{"lineNum":"  702","line":"        unsafe { OCaml::new(cr, ocaml_value.raw()) }","class":"lineCov","hits":"1","order":"961",},
{"lineNum":"  703","line":"    }","class":"lineCov","hits":"1","order":"963",},
{"lineNum":"  704","line":"}"},
{"lineNum":"  705","line":""},
{"lineNum":"  706","line":"pub struct OCamlIntable<T>(pub T);","class":"lineCov","hits":"1","order":"1672",},
{"lineNum":"  707","line":""},
{"lineNum":"  708","line":"unsafe impl<T> ToOCaml<OCamlInt> for OCamlIntable<T>"},
{"lineNum":"  709","line":"where"},
{"lineNum":"  710","line":"    T: TryInto<i64> + Copy,"},
{"lineNum":"  711","line":"    <T as TryInto<i64>>::Error: Debug,"},
{"lineNum":"  712","line":"{"},
{"lineNum":"  713","line":"    fn to_ocaml<\'a>(&self, _cr: &\'a mut OCamlRuntime) -> OCaml<\'a, OCamlInt> {","class":"lineCov","hits":"1","order":"1642",},
{"lineNum":"  714","line":"        OCaml::of_i64(self.0.try_into().expect(\"Couldn\'t convert to i64\"))","class":"lineCov","hits":"1","order":"1628",},
{"lineNum":"  715","line":"            .expect(\"Number couldn\'t fit in OCaml integer\")"},
{"lineNum":"  716","line":"    }","class":"lineCov","hits":"1","order":"942",},
{"lineNum":"  717","line":"}"},
{"lineNum":"  718","line":""},
{"lineNum":"  719","line":"pub fn unwrap_abstract_vec<T>(v: Vec<Abstract<T>>) -> Vec<T> {","class":"lineCov","hits":"1","order":"976",},
{"lineNum":"  720","line":"    v.into_iter().map(|Abstract(v)| v).collect()","class":"lineCov","hits":"1","order":"957",},
{"lineNum":"  721","line":"}","class":"lineCov","hits":"1","order":"969",},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "", "date" : "2023-09-23 10:46:05", "instrumented" : 263, "covered" : 214,};
var merged_data = [];
