var data = {lines:[
{"lineNum":"    1","line":"open! Core","class":"lineCov","hits":"1","order":"87",},
{"lineNum":"    2","line":""},
{"lineNum":"    3","line":"module Time_unit = struct","class":"lineCov","hits":"1","order":"84",},
{"lineNum":"    4","line":"  module T = struct","class":"lineCov","hits":"1","order":"86",},
{"lineNum":"    5","line":"    type t =","class":"lineCov","hits":"1","order":"91",},
{"lineNum":"    6","line":"      | Nanoseconds","class":"lineCov","hits":"1","order":"96",},
{"lineNum":"    7","line":"      | Microseconds","class":"lineCov","hits":"1","order":"98",},
{"lineNum":"    8","line":"      | Milliseconds","class":"lineCov","hits":"1","order":"93",},
{"lineNum":"    9","line":"    [@@deriving compare, sexp, enumerate, quickcheck]"},
{"lineNum":"   10","line":"  end"},
{"lineNum":"   11","line":""},
{"lineNum":"   12","line":"  include T","class":"lineCov","hits":"1","order":"95",},
{"lineNum":"   13","line":"  include Sexpable.To_stringable (T)","class":"lineCov","hits":"1","order":"85",},
{"lineNum":"   14","line":"end"},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"module T = struct","class":"lineCov","hits":"1","order":"83",},
{"lineNum":"   17","line":"  type t =","class":"lineCov","hits":"1","order":"92",},
{"lineNum":"   18","line":"    | Boolean","class":"lineCov","hits":"1","order":"1002",},
{"lineNum":"   19","line":"    | UInt8","class":"lineCov","hits":"1","order":"1741",},
{"lineNum":"   20","line":"    | UInt16","class":"lineCov","hits":"1","order":"1744",},
{"lineNum":"   21","line":"    | UInt32","class":"lineCov","hits":"1","order":"1746",},
{"lineNum":"   22","line":"    | UInt64","class":"lineCov","hits":"1","order":"1736",},
{"lineNum":"   23","line":"    | Int8","class":"lineCov","hits":"1","order":"1735",},
{"lineNum":"   24","line":"    | Int16","class":"lineCov","hits":"1","order":"1734",},
{"lineNum":"   25","line":"    | Int32","class":"lineCov","hits":"1","order":"1738",},
{"lineNum":"   26","line":"    | Int64","class":"lineCov","hits":"1","order":"1733",},
{"lineNum":"   27","line":"    | Float32","class":"lineCov","hits":"1","order":"1732",},
{"lineNum":"   28","line":"    | Float64","class":"lineCov","hits":"1","order":"1731",},
{"lineNum":"   29","line":"    | Utf8","class":"lineCov","hits":"1","order":"1766",},
{"lineNum":"   30","line":"    | Binary","class":"lineCov","hits":"1","order":"1730",},
{"lineNum":"   31","line":"    | Date","class":"lineCov","hits":"1","order":"1729",},
{"lineNum":"   32","line":"    | Datetime of Time_unit.t * string option","class":"lineCov","hits":"1","order":"1754",},
{"lineNum":"   33","line":"    | Duration of Time_unit.t","class":"lineCov","hits":"1","order":"1748",},
{"lineNum":"   34","line":"    | Time","class":"lineCov","hits":"1","order":"1767",},
{"lineNum":"   35","line":"    | List of t","class":"lineCov","hits":"1","order":"1750",},
{"lineNum":"   36","line":"        (* We want this branch to be tested very well, since code dealing with"},
{"lineNum":"   37","line":"           this recursive case is usually the most non-trivial portion of the"},
{"lineNum":"   38","line":"           logic. *)"},
{"lineNum":"   39","line":"        [@quickcheck.weight 10.]"},
{"lineNum":"   40","line":"    | Null","class":"lineCov","hits":"1","order":"1760",},
{"lineNum":"   41","line":"    | Struct of (string * t) list","class":"lineCov","hits":"1","order":"1752",},
{"lineNum":"   42","line":"    | Unknown","class":"lineCov","hits":"1","order":"1727",},
{"lineNum":"   43","line":"  [@@deriving compare, sexp, quickcheck]"},
{"lineNum":"   44","line":"end"},
{"lineNum":"   45","line":""},
{"lineNum":"   46","line":"include T","class":"lineCov","hits":"1","order":"90",},
{"lineNum":"   47","line":"include Sexpable.To_stringable (T)","class":"lineCov","hits":"1","order":"89",},
{"lineNum":"   48","line":""},
{"lineNum":"   49","line":"module Typed = struct","class":"lineCov","hits":"1","order":"79",},
{"lineNum":"   50","line":"  type untyped = t [@@deriving compare, sexp, quickcheck]","class":"lineCov","hits":"1","order":"94",},
{"lineNum":"   51","line":""},
{"lineNum":"   52","line":"  (* TODO: Consider mapping to smaller OCaml values like Int8, Float32, etc instead of"},
{"lineNum":"   53","line":"     casting up *)"},
{"lineNum":"   54","line":"  type _ t ="},
{"lineNum":"   55","line":"    | Boolean : bool t"},
{"lineNum":"   56","line":"    | UInt8 : int t"},
{"lineNum":"   57","line":"    | UInt16 : int t"},
{"lineNum":"   58","line":"    | UInt32 : int t"},
{"lineNum":"   59","line":"    | UInt64 : int t"},
{"lineNum":"   60","line":"    | Int8 : int t"},
{"lineNum":"   61","line":"    | Int16 : int t"},
{"lineNum":"   62","line":"    | Int32 : int t"},
{"lineNum":"   63","line":"    | Int64 : int t"},
{"lineNum":"   64","line":"    | Float32 : float t"},
{"lineNum":"   65","line":"    | Float64 : float t"},
{"lineNum":"   66","line":"    | Utf8 : string t"},
{"lineNum":"   67","line":"    | Binary : string t"},
{"lineNum":"   68","line":"    | List : \'a t -> \'a list t"},
{"lineNum":"   69","line":"    | Custom :"},
{"lineNum":"   70","line":"        { data_type : \'a t"},
{"lineNum":"   71","line":"        ; f : \'a -> \'b"},
{"lineNum":"   72","line":"        ; f_inverse : \'b -> \'a"},
{"lineNum":"   73","line":"        }"},
{"lineNum":"   74","line":"        -> \'b t"},
{"lineNum":"   75","line":""},
{"lineNum":"   76","line":"  let rec strict_type_equal : type a b. a t -> b t -> (a, b) Type_equal.t option =","class":"lineCov","hits":"1","order":"1740",},
{"lineNum":"   77","line":"    fun t1 t2 ->"},
{"lineNum":"   78","line":"    match t1, t2 with"},
{"lineNum":"   79","line":"    | Boolean, Boolean -> Some Type_equal.T","class":"lineCov","hits":"1","order":"1743",},
{"lineNum":"   80","line":"    | UInt8, UInt8 -> Some Type_equal.T"},
{"lineNum":"   81","line":"    | UInt16, UInt16 -> Some Type_equal.T"},
{"lineNum":"   82","line":"    | UInt32, UInt32 -> Some Type_equal.T"},
{"lineNum":"   83","line":"    | UInt64, UInt64 -> Some Type_equal.T"},
{"lineNum":"   84","line":"    | Int8, Int8 -> Some Type_equal.T"},
{"lineNum":"   85","line":"    | Int16, Int16 -> Some Type_equal.T"},
{"lineNum":"   86","line":"    | Int32, Int32 -> Some Type_equal.T"},
{"lineNum":"   87","line":"    | Int64, Int64 -> Some Type_equal.T"},
{"lineNum":"   88","line":"    | Float32, Float32 -> Some Type_equal.T"},
{"lineNum":"   89","line":"    | Float64, Float64 -> Some Type_equal.T"},
{"lineNum":"   90","line":"    | Utf8, Utf8 -> Some Type_equal.T"},
{"lineNum":"   91","line":"    | Binary, Binary -> Some Type_equal.T"},
{"lineNum":"   92","line":"    | List t1, List t2 ->","class":"lineCov","hits":"1","order":"1749",},
{"lineNum":"   93","line":"      (match strict_type_equal t1 t2 with","class":"lineCov","hits":"1","order":"1737",},
{"lineNum":"   94","line":"       | None -> None"},
{"lineNum":"   95","line":"       | Some Type_equal.T -> Some Type_equal.T)"},
{"lineNum":"   96","line":"    | _, _ -> None"},
{"lineNum":"   97","line":"  ;;"},
{"lineNum":"   98","line":""},
{"lineNum":"   99","line":"  let rec flatten_custom : type a. a t -> a t = function","class":"lineCov","hits":"1","order":"1001",},
{"lineNum":"  100","line":"    | Custom","class":"lineCov","hits":"1","order":"1753",},
{"lineNum":"  101","line":"        { data_type = Custom { data_type; f = f\'; f_inverse = f_inverse\' }; f; f_inverse }","class":"lineCov","hits":"1","order":"1728",},
{"lineNum":"  102","line":"      ->"},
{"lineNum":"  103","line":"      flatten_custom","class":"lineCov","hits":"1","order":"1756",},
{"lineNum":"  104","line":"        (Custom"},
{"lineNum":"  105","line":"           { data_type; f = Fn.compose f f\'; f_inverse = Fn.compose f_inverse\' f_inverse })","class":"lineCov","hits":"1","order":"1755",},
{"lineNum":"  106","line":"    | List t ->","class":"lineCov","hits":"1","order":"1757",},
{"lineNum":"  107","line":"      (match flatten_custom t with","class":"lineCov","hits":"1","order":"1758",},
{"lineNum":"  108","line":"       | Custom { data_type; f; f_inverse } ->","class":"lineCov","hits":"1","order":"1759",},
{"lineNum":"  109","line":"         Custom"},
{"lineNum":"  110","line":"           { data_type = List data_type","class":"lineNoCov","hits":"0",},
{"lineNum":"  111","line":"           ; f = List.map ~f","class":"lineNoCov","hits":"0",},
{"lineNum":"  112","line":"           ; f_inverse = List.map ~f:f_inverse","class":"lineNoCov","hits":"0",},
{"lineNum":"  113","line":"           }"},
{"lineNum":"  114","line":"       | t -> List t)","class":"lineCov","hits":"1","order":"1762",},
{"lineNum":"  115","line":"    | t -> t"},
{"lineNum":"  116","line":"  ;;"},
{"lineNum":"  117","line":""},
{"lineNum":"  118","line":"  type packed = T : _ t -> packed"},
{"lineNum":"  119","line":""},
{"lineNum":"  120","line":"  let rec to_untyped : type a. a t -> untyped = function","class":"lineCov","hits":"1","order":"1763",},
{"lineNum":"  121","line":"    | Boolean -> Boolean","class":"lineCov","hits":"1","order":"1764",},
{"lineNum":"  122","line":"    | UInt8 -> UInt8"},
{"lineNum":"  123","line":"    | UInt16 -> UInt16"},
{"lineNum":"  124","line":"    | UInt32 -> UInt32"},
{"lineNum":"  125","line":"    | UInt64 -> UInt64"},
{"lineNum":"  126","line":"    | Int8 -> Int8"},
{"lineNum":"  127","line":"    | Int16 -> Int16"},
{"lineNum":"  128","line":"    | Int32 -> Int32"},
{"lineNum":"  129","line":"    | Int64 -> Int64"},
{"lineNum":"  130","line":"    | Float32 -> Float32"},
{"lineNum":"  131","line":"    | Float64 -> Float64"},
{"lineNum":"  132","line":"    | Utf8 -> Utf8"},
{"lineNum":"  133","line":"    | Binary -> Binary"},
{"lineNum":"  134","line":"    | List t -> List (to_untyped t)","class":"lineCov","hits":"1","order":"1765",},
{"lineNum":"  135","line":"    | Custom { data_type; f = _; f_inverse = _ } -> to_untyped data_type","class":"lineCov","hits":"1","order":"1742",},
{"lineNum":"  136","line":"  ;;"},
{"lineNum":"  137","line":""},
{"lineNum":"  138","line":"  let rec of_untyped : untyped -> packed option = function","class":"lineCov","hits":"1","order":"1745",},
{"lineNum":"  139","line":"    | Boolean -> Some (T Boolean)","class":"lineCov","hits":"1","order":"1747",},
{"lineNum":"  140","line":"    | UInt8 -> Some (T UInt8)"},
{"lineNum":"  141","line":"    | UInt16 -> Some (T UInt16)"},
{"lineNum":"  142","line":"    | UInt32 -> Some (T UInt32)"},
{"lineNum":"  143","line":"    | UInt64 -> Some (T UInt64)"},
{"lineNum":"  144","line":"    | Int8 -> Some (T Int8)"},
{"lineNum":"  145","line":"    | Int16 -> Some (T Int16)"},
{"lineNum":"  146","line":"    | Int32 -> Some (T Int32)"},
{"lineNum":"  147","line":"    | Int64 -> Some (T Int64)"},
{"lineNum":"  148","line":"    | Float32 -> Some (T Float32)"},
{"lineNum":"  149","line":"    | Float64 -> Some (T Float64)"},
{"lineNum":"  150","line":"    | Utf8 -> Some (T Utf8)"},
{"lineNum":"  151","line":"    | Binary -> Some (T Binary)"},
{"lineNum":"  152","line":"    | List t -> of_untyped t |> Option.map ~f:(fun (T t) -> T (List t))","class":"lineCov","hits":"1","order":"1739",},
{"lineNum":"  153","line":"    | Date | Datetime _ | Duration _ | Time | Null | Struct _ | Unknown -> None"},
{"lineNum":"  154","line":"  ;;"},
{"lineNum":"  155","line":""},
{"lineNum":"  156","line":"  let rec sexp_of_packed (T t) =","class":"lineNoCov","hits":"0",},
{"lineNum":"  157","line":"    match t with"},
{"lineNum":"  158","line":"    | Custom { data_type; f = _; f_inverse = _ } ->","class":"lineNoCov","hits":"0",},
{"lineNum":"  159","line":"      let sexp = sexp_of_packed (T data_type) in","class":"lineNoCov","hits":"0",},
{"lineNum":"  160","line":"      [%message \"Custom\" ~_:(sexp : Sexp.t)]","class":"lineNoCov","hits":"0",},
{"lineNum":"  161","line":"    | _ -> [%sexp_of: untyped] (to_untyped t)","class":"lineNoCov","hits":"0",},
{"lineNum":"  162","line":"  ;;"},
{"lineNum":"  163","line":""},
{"lineNum":"  164","line":"  let compare_packed (T t1) (T t2) = [%compare: untyped] (to_untyped t1) (to_untyped t2)","class":"lineNoCov","hits":"0",},
{"lineNum":"  165","line":""},
{"lineNum":"  166","line":"  type \'a wrapped =","class":"lineCov","hits":"1","order":"97",},
{"lineNum":"  167","line":"    | Just of \'a","class":"lineCov","hits":"1","order":"1761",},
{"lineNum":"  168","line":"    | Wrapped of \'a wrapped","class":"lineCov","hits":"1","order":"1751",},
{"lineNum":"  169","line":"  [@@deriving quickcheck]"},
{"lineNum":"  170","line":""},
{"lineNum":"  171","line":"  let rec unwrap : packed wrapped -> packed = function","class":"lineCov","hits":"1","order":"1726",},
{"lineNum":"  172","line":"    | Just t -> t","class":"lineCov","hits":"1","order":"1725",},
{"lineNum":"  173","line":"    | Wrapped wrapped ->","class":"lineCov","hits":"1","order":"1724",},
{"lineNum":"  174","line":"      let (T data_type) = unwrap wrapped in","class":"lineCov","hits":"1","order":"1723",},
{"lineNum":"  175","line":"      T (Custom { data_type; f = Fn.id; f_inverse = Fn.id })","class":"lineCov","hits":"1","order":"1722",},
{"lineNum":"  176","line":"  ;;"},
{"lineNum":"  177","line":""},
{"lineNum":"  178","line":"  let quickcheck_generator_packed ="},
{"lineNum":"  179","line":"    let generator_without_custom ="},
{"lineNum":"  180","line":"      Quickcheck.Generator.filter_map quickcheck_generator ~f:of_untyped","class":"lineCov","hits":"1","order":"82",},
{"lineNum":"  181","line":"    in"},
{"lineNum":"  182","line":"    quickcheck_generator_wrapped generator_without_custom","class":"lineCov","hits":"1","order":"81",},
{"lineNum":"  183","line":"    |> Quickcheck.Generator.map ~f:unwrap"},
{"lineNum":"  184","line":"  ;;"},
{"lineNum":"  185","line":""},
{"lineNum":"  186","line":"  let quickcheck_shrinker_packed ="},
{"lineNum":"  187","line":"    Quickcheck.Shrinker.filter_map","class":"lineCov","hits":"1","order":"80",},
{"lineNum":"  188","line":"      quickcheck_shrinker"},
{"lineNum":"  189","line":"      ~f:of_untyped"},
{"lineNum":"  190","line":"      ~f_inverse:(fun (T t) -> to_untyped t)","class":"lineNoCov","hits":"0",},
{"lineNum":"  191","line":"  ;;"},
{"lineNum":"  192","line":""},
{"lineNum":"  193","line":"  let quickcheck_observer_packed ="},
{"lineNum":"  194","line":"    Quickcheck.Observer.unmap quickcheck_observer ~f:(fun (T t) -> to_untyped t)","class":"lineCov","hits":"1","order":"88",},
{"lineNum":"  195","line":"  ;;"},
{"lineNum":"  196","line":"end","class":"lineCov","hits":"1","order":"78",},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "", "date" : "2023-09-23 10:46:05", "instrumented" : 79, "covered" : 69,};
var merged_data = [];
