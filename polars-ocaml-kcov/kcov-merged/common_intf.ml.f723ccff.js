var data = {lines:[
{"lineNum":"    1","line":"open! Core","class":"lineCov","hits":"1","order":"55",},
{"lineNum":"    2","line":""},
{"lineNum":"    3","line":"module type Compare = sig"},
{"lineNum":"    4","line":"  type t"},
{"lineNum":"    5","line":""},
{"lineNum":"    6","line":"  val ( = ) : t -> t -> t"},
{"lineNum":"    7","line":"  val ( <> ) : t -> t -> t"},
{"lineNum":"    8","line":"  val ( > ) : t -> t -> t"},
{"lineNum":"    9","line":"  val ( >= ) : t -> t -> t"},
{"lineNum":"   10","line":"  val ( < ) : t -> t -> t"},
{"lineNum":"   11","line":"  val ( <= ) : t -> t -> t"},
{"lineNum":"   12","line":"end"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"module type Numeric_basic = sig"},
{"lineNum":"   15","line":"  type t"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"  val add : t -> t -> t"},
{"lineNum":"   18","line":"  val sub : t -> t -> t"},
{"lineNum":"   19","line":"  val mul : t -> t -> t"},
{"lineNum":"   20","line":"  val div : t -> t -> t"},
{"lineNum":"   21","line":"end"},
{"lineNum":"   22","line":""},
{"lineNum":"   23","line":"module type Numeric = sig"},
{"lineNum":"   24","line":"  include Numeric_basic"},
{"lineNum":"   25","line":""},
{"lineNum":"   26","line":"  val ( + ) : t -> t -> t"},
{"lineNum":"   27","line":"  val ( - ) : t -> t -> t"},
{"lineNum":"   28","line":"  val ( * ) : t -> t -> t"},
{"lineNum":"   29","line":"  val ( / ) : t -> t -> t"},
{"lineNum":"   30","line":"end"},
{"lineNum":"   31","line":""},
{"lineNum":"   32","line":"module type Logic_basic = sig"},
{"lineNum":"   33","line":"  type t"},
{"lineNum":"   34","line":""},
{"lineNum":"   35","line":"  val not : t -> t"},
{"lineNum":"   36","line":"  val and_ : t -> t -> t"},
{"lineNum":"   37","line":"  val or_ : t -> t -> t"},
{"lineNum":"   38","line":"  val xor : t -> t -> t"},
{"lineNum":"   39","line":"end"},
{"lineNum":"   40","line":""},
{"lineNum":"   41","line":"module type Logic = sig"},
{"lineNum":"   42","line":"  include Logic_basic"},
{"lineNum":"   43","line":""},
{"lineNum":"   44","line":"  val ( ! ) : t -> t"},
{"lineNum":"   45","line":"  val ( && ) : t -> t -> t"},
{"lineNum":"   46","line":"  val ( || ) : t -> t -> t"},
{"lineNum":"   47","line":"  val ( lxor ) : t -> t -> t"},
{"lineNum":"   48","line":"end"},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"module type Common = sig"},
{"lineNum":"   51","line":"  module type Compare = Compare"},
{"lineNum":"   52","line":"  module type Numeric = Numeric"},
{"lineNum":"   53","line":"  module type Logic = Logic"},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":"  module Make_numeric (T : Numeric_basic) : Numeric with type t := T.t"},
{"lineNum":"   56","line":"  module Make_logic (T : Logic_basic) : Logic with type t := T.t"},
{"lineNum":"   57","line":""},
{"lineNum":"   58","line":"  module Naive_date : sig"},
{"lineNum":"   59","line":"    type t"},
{"lineNum":"   60","line":""},
{"lineNum":"   61","line":"    val create : year:int -> month:int -> day:int -> t option"},
{"lineNum":"   62","line":"    val of_date : Date.t -> t"},
{"lineNum":"   63","line":"    val of_string : string -> t"},
{"lineNum":"   64","line":"  end"},
{"lineNum":"   65","line":""},
{"lineNum":"   66","line":"  module Naive_datetime : sig"},
{"lineNum":"   67","line":"    type t"},
{"lineNum":"   68","line":""},
{"lineNum":"   69","line":"    val of_naive_date : ?hour:int -> ?min:int -> ?sec:int -> Naive_date.t -> t"},
{"lineNum":"   70","line":"    val of_date : ?hour:int -> ?min:int -> ?sec:int -> Date.t -> t"},
{"lineNum":"   71","line":"    val to_string : t -> string"},
{"lineNum":"   72","line":"    val of_string : string -> t"},
{"lineNum":"   73","line":"    val of_time_ns : Time_ns.t -> t option"},
{"lineNum":"   74","line":"    val of_time_ns_exn : Time_ns.t -> t"},
{"lineNum":"   75","line":"    val to_time_ns : t -> Time_ns.t"},
{"lineNum":"   76","line":"  end"},
{"lineNum":"   77","line":""},
{"lineNum":"   78","line":"  val record_panic_backtraces : unit -> unit"},
{"lineNum":"   79","line":""},
{"lineNum":"   80","line":"  module For_testing : sig"},
{"lineNum":"   81","line":"    val panic : string -> unit"},
{"lineNum":"   82","line":""},
{"lineNum":"   83","line":"    (** [clear_panic_hook] sets the panic handler to a no-op. We\'ve found that"},
{"lineNum":"   84","line":"        the output of the default panic hook does not seem to be stable across"},
{"lineNum":"   85","line":"        Rust versions, so this should be used in expect tests where we expect"},
{"lineNum":"   86","line":"        panic-driven exceptions. *)"},
{"lineNum":"   87","line":"    val clear_panic_hook : unit -> unit"},
{"lineNum":"   88","line":"  end"},
{"lineNum":"   89","line":"end","class":"lineCov","hits":"1","order":"54",},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "", "date" : "2023-09-23 10:46:05", "instrumented" : 2, "covered" : 2,};
var merged_data = [];
